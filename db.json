{
	"getMockMarkDown": [{
			"createdTime": "2023-10-11 15:55:54",
			"updatedTime": "2024-03-04T12:05:16",
			"createdBy": 1,
			"updatedBy": 1,
			"articleId": "1712014142140878849",
			"articleTitle": "windows10系统上安装多个解压版的MySQL数据库",
			"articleSummary": "近几年，MySQL数据库越来越流行，使用率非常高，经常会遇到开发环境和生产环境中，MySQL的版本不一致的问题，那如何解决这个问题呢？下面就来介绍一下，如何在同一台电脑中装多个不同版本的MySQL服务。本篇文章以windows10系统安装MySQL 5.7.42 和MySQL 8.0.33这2个不同版本的MySQL为例进行举例说明。",
			"articleCategory": "1712008554694610946",
			"articleContent": "## 1 MySQL多版本安装\n在`windows`系统上，MySQL数据库的安装方式有2种`MSI Installer`和`ZIP Archive`。本文主要讲解通过`ZIP Archive`解压缩包的方式，安装配置`MySQL 5.7.42` 和`MySQL 8.0.33` 2个不同版本的MySQL数据库实例。\n> 下文中的`MySQL5`和`MySQL8分别为`MySQL 5.7.42`和`MySQL 8.0.33`的简称，同时也是对应版本的`MySQL`服务名称，下文中统一用`MySQL5`代指`MySQL 5.7.42`，`MySQL8`代指`MySQL 8.0.33`。\n### 1.1 MySQL官网\n1、MySQL最新版本下载地址：[https://dev.mysql.com/downloads/mysql/](https://dev.mysql.com/downloads/mysql/)，选择当前稳定的`MySQL`版本和对应的操作系统，然后下载压缩包，如下图所示：\n![](https://cdn.jsdelivr.net/gh/AnyFork/blog-images/markdown/202310111800650.png)\n2、MySQL历史版本下载地址：[https://downloads.mysql.com/archives/community/](https://downloads.mysql.com/archives/community/)，选择对应的`MySQL`历史版本和操作系统，然后下载压缩包，如下图所示：\n![](https://cdn.jsdelivr.net/gh/AnyFork/blog-images/markdown/202310111808113.png)\n### 1.2 MySQL下载\n1、分别选择`MySQL 5.7.42`和`MySQL 8.0.33`windows版本，并下载压缩包文件至本地。\n2、分别加压缩至`D:\\MySQL\\mysql-5.7.42-winx64`和`D:\\MySQL\\mysql-8.0.33-winx64`\n## 2 MySQL5.7.42安装\n将免安装版的`MySQL 5.7.42`解压到希望安装的目录。本次示例选择的目录是：`D:\\MySQL\\mysql-5.7.42-winx64`\n### 2.1 配置my.ini文件\n如果解压后的`MySQL 5.7.42`安装包里有`my-default.ini`，则复制一份改为`my.ini`；如果没有`my-default.ini`则新建一个`my.ini`文件。\n```my.ini\n[mysql]\n# 设置mysql客户端默认字符集\ndefault-character-set=utf8\n[mysqld]\n#设置3307端口\nport = 3307\n# 设置mysql的安装目录和数据存放目录\nbasedir=D:\\MySQL\\mysql-5.7.42-winx64\ndatadir=D:\\MySQL\\mysql-5.7.42-winx64\\data\n# 允许最大连接数\nmax_connections=200\n# 服务端使用的字符集默认为UTF8\ncharacter-set-server=utf8\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=INNODB\n#跳过数据库权限验证 skip the password\nskip_grant_tables\n# 配置Sql Mode\nsql_mode='STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'\n```\n!!! attention 注意：\n`my.ini`还需要加跳过密码登录的配置，否则在初次登陆时会报：ERROR 1045 (28000): Access denied for user 'ODBC'@'localhost' (using password: NO)\n!!!\n### 2.2 安装MySQL\n1、以管理员身份运行`cmd`，进入`MySQL 5.7.42`的bin目录下。\n2、输入`mysqld --initialize-insecure --user=mysql`回车，此时在`MySQL 5.7.42`根目录下会生成一个data文件夹。\n3、执行以下命令，安装`MySQL5`。\n```MySQL\nmysqld install MySQL5 --defaults-file=\"D:\\MySQL\\mysql-5.7.42-winx64\\my.ini\"\n```\n!!! info 备注：\n1、`MySQL5`可改为任意名称，它是安装后的`MySQL`服务名,用于区分不同版本的`MySQL`;defaults-file=“my.ini的存放目录”。\n2、`MySQL5`初始化后，会在根目录生产data文件夹，查看.err文件是否存在错误，如果存在错误，无法启动。\n!!!\n### 2.3 查看注册表\n1、运行`regedit`打开注册表，到`HKEY_LOCAL_MACHINE–>SYSTEM–>CurrentControlSet–>Services` 下找到`MySQL5`名称的注册表。\n2、查看`mysqld.exe`文件和`my.ini`文件是否是本次安装`MySQL5`时的文件，如果不是一定要修改，不然在启动`MySQL5`服务时会报错，并且无法成功启动。\n![](https://cdn.jsdelivr.net/gh/AnyFork/blog-images/markdown/202310111848345.png)\n### 2.4 运行MySQL\n1、以管理员身份运行`cmd`。\n2、执行以下命令，启动`MySQL5`服务\n```shell\nnet start MySQL5\n```\n### 2.5 登录MySQL\n1、如果安装`MySQL5`时使用的是3306端口，登录的命令：`mysql -uroot -p`\n2、如果安装`MySQL5`时使用的是其他端口，登录时的命令：`mysql -P端口 -uroot -p`\n3、这时会提示你输入密码。如果在my.ini里配置了跳过密码验证`skip_grant_tables`，则不需要输入，不然就需要打开MySQL根目录下的data文件夹，找到后缀是.err的文件以文本打开找到password临时密码（可以ctrl+f搜索）然后在cmd中输入该临时密码。\n4、修改`root`账号密码\n```mysql\nset password for root@localhost = password('新密码');\n```\n!!! attention 注意：\n1、`skip-grant-tables`，`MySQL`登录时跳过数据库权限验证，无需输入密码。但是在修改密码时会报错：\nERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement\n2、通过刷新权限`flush privileges;`解决上面错误问题，此时便可以修改密码。\n3、上面修改密码命令，只适用于`MySQL5.X`以下版本。\n!!!\n5、刷新权限\n```mysql\nflush privileges;\n```\n6、退出MySQL\n```mysql\nexit;\n```\n7、首次登录后，密码已修改完毕，更改`my.ini`里设置的跳过密码配置。先停止`MySQL5`服务，注释掉`skip-grant-tables`，然后重启`MySQL5`服务即可。\n## 3 MySQL8.0.33安装\n将免安装版的`MySQL 8.0.33`解压到希望安装的目录。本次示例选择的目录是：`D:\\MySQL\\mysql-8.0.33-winx64`\n### 3.1 配置my.ini文件\n如果解压后的`MySQL 8.0.33`安装包里有`my-default.ini`，则复制一份改为`my.ini`；如果没有`my-default.ini`则新建一个`my.ini`文件。\n```my.ini\n[mysql]\n# 设置mysql客户端默认字符集\ndefault-character-set=utf8mb4\n[mysqld]\n#设置3306端口\nport = 3306\n# 设置mysql的安装目录和数据存放目录\nbasedir=D:\\MySQL\\mysql-8.0.33-winx64\ndatadir=D:\\MySQL\\mysql-8.0.33-winx64\\data\n# 允许最大连接数\nmax_connections=200\n# 允许连接失败的次数。\nmax_connect_errors=10\n# 服务端使用的字符集默认为utf8mb4\ncharacter-set-server=utf8mb4\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=INNODB\n# 默认使用“mysql_native_password”插件认证\nauthentication_policy=mysql_native_password\n# 配置Sql Mode\nsql_mode='NO_AUTO_VALUE_ON_ZERO,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION,PIPES_AS_CONCAT,ANSI_QUOTES'\n[client]\n# 设置mysql客户端连接服务端时默认使用的端口\nport=3306\ndefault-character-set=utf8mb4\n```\n### 3.2 安装MySQL\n1、以管理员身份运行`cmd`，进入`MySQL8.0.33`的`bin`目录下。\n2、执行初始化命令，输入mysqld --initialize回车，此时在`MySQL8.0.33`根目录下会生成一个data文件夹。**注意：这个命令不需要附加参数，即不需要指定my.ini配置文件**。\n```mysql\nmysqld --initialize\n```\n3、执行命令，安装`MySQL8`\n```mysql\nmysqld install MySQL8\n```\n!!! attention 注意：\n1、这个命令不需要附加参数，即不需要指定`my.ini`配置文件。如果和安装`5.7.42`时一样指定`my.ini`，`MySQL8`服务在安装完毕后，启动时会启动失败，原因未知。\n2、MySQL8可改为任意名称，它是MySQL8安装后的MySQL服务名。\n!!!\n### 3.3 运行MySQL\n1、以管理员身份运行`cmd`。\n2、执行以下命令，启动`MySQL8`服务\n```shell\nnet start MySQL8\n```\n### 3.4 登录MySQL\n1、如果安装`MySQL8`时使用的是`3306`端口，登录的命令：`mysql -uroot -p`\n2、如果安装`MySQL8`时使用的是其他端口，登录时的命令：`mysql -P端口 -uroot -p`\n3、到data文件夹下，查找.err类型的文件查看密码。\n4、登陆成功后可修改密码：\n```mysql\nALTER USER 'root'@'localhost' IDENTIFIED BY 'root';\n```\n5、刷新权限\n```mysql\nflush privileges;\n```\n6、退出MySQL\n```mysql\nexit;\n```\n## 3 篇尾小结\n1、`MySQL`安装核心就是注册安装`MySQL`服务为不同名称的系统应用，并运行在不同的端口上。\n2、通过命令`mysqld -install`安装`MySQL`时，默认应用名为`MySQL`,可以通过`mysqld -install MySQL8`变更应用名称。\n3、`MySQL5.X`和`MySQL8.X`在安装时，除了配置文件`my.ini`中参数存在和SQL执行命令存在差异，大的步骤基本一致。\n4、`MySQL`环境变量是不需要强制配置的。加到`path`里面只是为了全局都可以用`mysql.exe`,`mysqladmin.exe`等命令，如果不加我们如果要通过`cmd`来打开mysql的话就每次都先cd到bin目录下面,依然可以执行相关命令。安装多个版本`MySQL`，配置了环境变量，切换还比较麻烦。\n\n\n\n\n\n\n\n\n",
			"articleWords": 1849,
			"articleReadTime": "6.16",
			"articleKeyWords": "MySQL，MySQL本地安装，MySQL 多个版本服务，安装不同版本MySQL",
			"articleDescription": "近几年，MySQL数据库越来越流行，使用率非常高，经常会遇到开发环境和生产环境中，MySQL的版本不一致的问题，那如何解决这个问题呢？下面就来介绍一下，如何在同一台电脑中装多个不同版本的MySQL服务。本篇文章以windows10系统安装MySQL 5.7.42 和MySQL 8.0.33这2个不同版本的MySQL为例进行举例说明。",
			"articleAvatar": "https://cdn.jsdelivr.net/gh/AnyFork/blog-images/markdown/202203141729266.gif",
			"articleReadCount": 8,
			"articleStatus": "0",
			"categoryInfo": {
				"createdTime": "2023-10-11 15:33:42",
				"createdBy": 1,
				"categoryId": "1712008554694610946",
				"categoryName": "MySQL",
				"iconName": "logos:mysql",
				"categoryStatus": "0",
				"categoryAlias": "mysql",
				"orderNum": 46,
				"articleTotal": 0
			},
			"tagInfo": [{
				"createdTime": "2023-10-11 15:35:53",
				"updatedTime": "2023-10-12T11:10:49",
				"createdBy": 1,
				"updatedBy": 1,
				"tagId": "1712009106220421121",
				"tagName": "软件安装",
				"tagAlias": "install",
				"tagIcon": "icon-park-twotone:install",
				"iconColor": "rgb(79, 218, 19)",
				"tagSort": 5,
				"tagStatus": "0",
				"articleTotal": 0
			}]
		},
		{
			"createdTime": "2023-07-21 21:47:21",
			"updatedTime": "2023-07-24T23:04:38",
			"createdBy": 1,
			"updatedBy": 1,
			"articleId": "1682386785042206721",
			"articleTitle": "基于vite构建简洁通用的vue3项目模板",
			"articleSummary": "这是一个基于Vite4.X + Vue3.X + TypeScript + Naive UI + Pinia + VueRouter + Unocss + Alova + Eslint + Prettier + husky + lint-staged + commitlint + commitizen + cz-customizable+ conventional-changelog构建的标准的，简单通用的vue项目模板。",
			"articleCategory": "1665584221287206914",
			"articleContent": "## 一 项目简介\n\n对于多人协作开发来说，项目开发规范标准，非常重要，不仅能够统一标准，规范代码书写风格，还能便于后期维护和运营。\n\n一直以来，每次采用`vite`搭建`Vue3`项目时，都苦于配置`Eslint`代码校验规范，网上的水贴层出不穷，你抄我的，我粘贴你的，没有几个是有用的，不仅容易误导他人，还浪费大量的时间排查问题。最近花了一些时间，查阅了很多资料，自己也通过反复验证，决定自己搭建一个简单的模板，集成好日常代码开发规范和提交规范，把常用的`Vite`插件都配置好，在以后创建项目时直接使用，避免重复造轮子，同时也供他人参考。\n\n## 二 项目创建\n\n1 采用`pnpm`创建项目\n\n```shell\npnpm create vite\n```\n\n2 依赖安装\n\n```shell\npnpm install\n```\n\n3 项目运行\n\n```shell\npnpm dev\n```\n\n## 三 设置依赖\n项目创建完后，我们开始增加一些日常开发过程中经常使用的`vite`插件和项目工具包，方便我们能够快速开发项目。\n### 1 Vite插件\n#### 1 unplugin-auto-import\n> 官网：https://github.com/antfu/unplugin-auto-import\n\n`unplugin-auto-import`是为 `Vite、Webpack、Rollup` 和 `esbuild` 按需自动导入`API`。例如：`ref,reactive`等API无需额外导入，就可以全局使用。\n##### 1.1 依赖安装\n```shell\npnpm install unplugin-auto-import -D\n```\n\n##### 1.2 插件配置\n在`vite.config.ts`中进行插件配置，如下：\n```ts\nexport default defineConfig(){\n    plugins:[\n      ...\n       //自动导入Composition API,https://github.com/antfu/unplugin-auto-import\n      AutoImport({\n        dts: \"src/types/auto-import.d.ts\",\n        imports: [\n          \"vue\"\n        ],\n      }),\n      ...\n    ]\n}\n```\n上面已经配置了`vue`框架自动导入API\n\n#### 2 unplugin-vue-components\n>官网：https://github.com/antfu/unplugin-vue-components\n\n`unplugin-vue-components`是一款组件自动导入`Vite`插件，可以自定义需要自动导入的组件目录，无需使用时手动导入。\n\n##### 2.1 依赖安装\n```shell\npnpm install unplugin-vue-components -D\n```\n##### 2.2 插件配置\n在`vite.config.ts`中进行插件配置，如下：\n```ts\nexport default defineConfig(){\n    plugins:[\n      ...\n        //自动导入组件，https://github.com/antfu/unplugin-vue-components\n        Components({\n          dts: \"src/types/components.d.ts\",\n          dirs: ['src/components'],\n          resolvers: [],\n        }),\n      ...\n    ]\n}\n```\n#### 3 unplugin-vue-setup-extend-plus\n> 官网：https://github.com/chenxch/unplugin-vue-setup-extend-plus\n\n`Vue3`组件自定义命名插件，可以在`<script setup lang=ts name=\"Good\"></script>`标签中，通过设置name属性为组件命名\n\n##### 3.1 依赖安装\n```shell\npnpm install unplugin-vue-setup-extend-plus -D\n```\n##### 3.2 插件配置\n在`vite.config.ts`中进行插件配置，如下：\n```ts\nexport default defineConfig(){\n    plugins:[\n      ...\n      //官网：https://github.com/chenxch/unplugin-vue-setup-extend-plus\n      vueSetupExtend({\n        //禁止组件属性自动导出\n        enableAutoExpose: false,\n      }),\n      ...\n    ]\n}\n```\n配置完毕后，我们可以为组件进行命名。例如:`SvgIcon`组件：\n```vue\n<script setup lang=\"ts\" name=\"SvgIcon\">\n</script>\n```\n#### 4 vite-plugin-html\n> 官网地址：https://github.com/vbenjs/vite-plugin-html/blob/main/README.zh_CN.md\n\n`vite-plugin-html`插件可以在`html`页面中使用`ejs`语法，动态注入数据。\n\n##### 4.1 依赖安装\n```shell\npnpm install vite-plugin-html -D\n```\n##### 4.2 插件配置\n1 在`vite.config.ts`中进行插件配置，如下：\n```ts\nexport default defineConfig(){\n    plugins:[\n      ...\n      //在html中创建ejs标签，官网地址：https://github.com/vbenjs/vite-plugin-html/blob/main/README.zh_CN.md\n      createHtmlPlugin({\n        // 是否压缩 html\n        minify: true,\n        /**\n         * 需要注入 index.html ejs 模版的数据\n         */\n        inject: {\n          data: {\n            title: env.VITE_SYSTEM_TITLE,\n            description: env.VITE_SYSTEM_DESC\n          }\n        }\n      }),\n      ...\n    ]\n}\n```\n`inject`中的data就是要注入的变量参数，`env`为环境变量参数。可以通过一下代码获取到：\n```ts\nimport { loadEnv } from 'vite'\nconst env = loadEnv(mode, process.cwd())\n```\n2 修改`index.html`文件，将`vite-plugin-html`插件注入的数据，通过`ejs`语法写入`index.html`,如下:\n```html\n<!doctype html>\n<html lang=\"zh-CN\">\n    <head>\n        <meta charset=\"UTF-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <meta name=\"description\" content=\"<%=description%>\" />\n        <link rel=\"icon\" type=\"image/svg+xml\" href=\"/logo.svg\" />\n        <title><%= title %></title>\n    </head>\n\n    <body>\n        <div id=\"app\">\n            <div id=\"loading\"></div>\n        </div>\n        <script type=\"module\" src=\"/src/main.ts\"></script>\n    </body>\n</html>\n```\n#### 5 vite-plugin-svg-icons\n> 官网:https://github.com/vbenjs/vite-plugin-svg-icons/blob/main/README.zh_CN.md\n\n`vite-plugin-svg-icons`是一款用于生成`svg` 雪碧图的插件，能够将本地指定文件目录下的`Svg`生成一张雪碧图，在项目运行时就生成所有图标,只需操作一次`dom`,内置缓存,仅当文件被修改时才会重新生成。通过`Svg`名称便可以加载对应的`Svg`图标。\n\n##### 5.1 依赖安装\n```shell\npnpm install vite-plugin-svg-icons -D\n```\n##### 5.2 插件配置\n1 在`vite.config.ts`中进行插件配置，如下：\n```ts\nimport { createSvgIconsPlugin } from 'vite-plugin-svg-icons'\nimport path from 'path'\nexport default defineConfig(){\n    plugins:[\n      ...\n      createSvgIconsPlugin({\n       //// 指定需要缓存的svg图标文件夹\n       iconDirs: [path.resolve(process.cwd(), 'src/assets/svg')],\n       // 指定symbolId格式\n       symbolId: 'icon-local-[dir]-[name]`,\n       // 自定义插入位置,@default: body-last\n       inject: 'body-last',\n       //自定义domId,默认：__svg__icons__dom__\n       customDomId: '__SVG_ICON_LOCAL__'\n      })\n      ...\n    ]\n}\n```\n2 在`main.js`中增加以下代码\n```js\nimport 'virtual:svg-icons-register'\n```\n3 将需要的`svg`图标放入与`iconDirs`设置的路径中，项目中为`src/assets/svg`\n```svg\n<svg aria-hidden=\"true\" style=\"width: 14px; height: 14px\">\n\t<use :href=\"`#icon-local-${menu.icon}`\" />\n</svg>\n```\n`menu.icon`是路径里面的`svg`图片名称。这个是简单用法，项目中已封装成了组件`SvgIcon`,请前往自行查看。\n\n4 如果使用`Typescript`,你可以在`tsconfig.json`内添加:\n```json\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"types\": [\"vite-plugin-svg-icons/client\"]\n  }\n}\n```\n#### 6 @iconify/vue\n> 官网：https://iconify.design/docs/icon-components/vue/\n\n`iconify`是功能最丰富的图标框架。可以与任何图标库一起使用的统一图标框架。开箱即用的功能包括80多个图标集和超过70,000个图标。官方为了便于使用`iconify`网站上的图标，提供了`@iconify/vue`组件，供大家使用`SVG framework`，支持在线和离线2种方式使用。离线方式需要下载对应图标集合`json`数据，然后先从本地资源中加载，如果没有找到，通过API从线上下载资源，并进行浏览器缓存。\n\n`@iconify/vue`是一个功能非常强大的组件，支持图标名称动态渲染和静态渲染，正好弥补`vite-plugin-svg-icons`功能缺陷。\n##### 6.1 依赖安装\n```shell\npnpm install @iconify/vue -D\n```\n##### 6.2 使用例子\n```ts\nimport { Icon } from '@iconify/vue';\n<Icon icon=\"mdi-light:home\" />\n```\n##### 6.3 自定义组件\n虽然`@iconify/vue`也支持本地`svg`,但逐个配置非常麻烦，所以结合`vite-plugin-svg-icons`和`@iconify/vue`,我们创建一个自定义组件，使其不仅支持本地静态动态`Svg`渲染，还支持显示静态动态`Svg`渲染。下面是自定义组件代码：\n```vue\n<template>\n    <template v-if=\"localIcon\">\n        <svg aria-hidden=\"true\" width=\"1em\" height=\"1em\" v-bind=\"bindAttrs\">\n            <use :xlink:href=\"symbolId\" fill=\"currentColor\" />\n        </svg>\n    </template>\n    <template v-else>\n        <Icon v-if=\"icon\" :icon=\"icon\" v-bind=\"bindAttrs\" />\n    </template>\n</template>\n\n<script setup lang=\"ts\" name=\"SvgIcon\">\nimport { Icon } from '@iconify/vue'\n// eslint-disable-next-line vue/no-setup-props-destructure\nconst { icon, localIcon } = defineProps<{\n    /** iconify线上图标名称 */\n    icon?: string\n    /** 本地svg的文件名称 */\n    localIcon?: string\n}>()\n// 获取组件传递的属性\nconst attrs = useAttrs()\n// 计算绑定属性\nconst bindAttrs = computed<{ class: string; style: string }>(() => ({\n    class: (attrs.class as string) ?? 'w-24px h-24px',\n    style: attrs.style as string\n}))\n// 计算本地svg动态的symbolId\nconst symbolId = computed(() => {\n    const icon = localIcon ?? 'no-icon'\n    return `#icon-local-${icon}`\n})\n</script>\n```\n此时，便可以灵活的渲染本地和线上`iconify`网站上的`Svg`图标，使用例子如下：\n```vue\n本地Svg:<SvgIcon localIcon=\"logo\"></SvgIcon>\niconify线上Svg:<SvgIcon icon=\"healthicons:fhir-logo\" class=\"w-24px h-24px\"></SvgIcon>\n```\n\n#### 7 rollup-plugin-visualizer\n> 官网：https://github.com/btd/rollup-plugin-visualizer\n\n`rollup-plugin-visualizer`是一个用于Rollup构建工具的插件，一款用于项目性能优化，打包体积分析，能够生成可视化的构建报告，帮助开发者更好地了解构建过程中的文件大小、依赖关系等信息的插件。\n\n##### 7.1 依赖安装\n```shell\npnpm install rollup-plugin-visualizer -D\n```\n\n##### 7.2 插件配置\n\n1 在`vite.config.ts`中进行插件配置，如下：\n```ts\n// 引入rollup-plugin-visualizer模块\nimport { visualizer } from \"rollup-plugin-visualizer\";\nexport default defineConfig(){\n    plugins:[\n      ...\n      visualizer({\n        //注意这里要设置为true，打包时会自动打开分析页面。\n        open:true,  \n        //分析图生成的文件名\n        filename: \"stats.html\", \n        //收集gzip大小并将其显示\n        gzipSize: true, // \n        //收集 brotli 大小并将其显示\n        brotliSize: true, \n      })\n      ...\n    ]\n}\n```\n2 运行运行命令打包，生成分析图\n\n输入`pnpm build`打包项目，等待片刻，生成分析视图，视图会自动跳出来，并保存在项目根目录下，文件名就是刚刚参数filename的名字（stats.html）\n\n![](https://cdn.staticaly.com/gh/AnyFork/blog-images/main/markdown/202307211635849.png)\n\n视图分析中方块越大，表示该文件占用的空间越大，对于网络带宽和访问速度的要求就越高。如果一个网站中包含大量的大文件，那么用户在访问该网站时需要下载更多的数据，这会导致网站加载速度变慢，用户体验变差。\n\n#### 8 vite-plugin-compression\n> 官网：https://github.com/vbenjs/vite-plugin-compression\n\n`gzip`压缩：当前端资源过大时，服务器请求资源会比较慢。前端可以将资源通过`Gzip`压缩使文件体积减少大概60%左右，压缩后的文件，通过后端简单处理，浏览器可以将其正常解析出来。如果浏览器的请求头中包含`content-encoding: gzip`，即证明浏览器支持该属性。\n\n`vite`中使用`vite-plugin-compression`插件可以很便捷的对代码进行`gzip`压缩，减少代码体积，加快浏览器访问速度。压缩的代码放到服务器后，需要后端配置一些东西，浏览器才可以解析。比如可以配置nginx.\n\n##### 8.1 依赖安装\n```shell\npnpm install vite-plugin-compression -D\n```\n##### 8.2 插件配置\n在`vite.config.ts`中进行插件配置，如下：\n```ts\n// 引入vite-plugin-compression模块\nimport viteCompression from 'vite-plugin-compression';\nexport default defineConfig(){\n    plugins:[\n      ...\n      viteCompression()\n      ...\n    ]\n}\n```\n#### 9 完整的vite.config.ts\n下面展示整个项目`vite.config.ts`完整的配置，代码如下\n```ts\n//vite.config.ts\nimport { type ConfigEnv, defineConfig, loadEnv } from 'vite'\nimport vue from '@vitejs/plugin-vue'\n// 该包是用于配置vite运行的时候自动检测eslint规范,不符合规范，启动时不会报错，页面刷新时会报错，https://github.com/gxmari007/vite-plugin-eslint\nimport eslint from 'vite-plugin-eslint'\nimport { visualizer } from 'rollup-plugin-visualizer'\nimport ViteCompression from 'vite-plugin-compression'\nimport Components from 'unplugin-vue-components/vite'\nimport { NaiveUiResolver } from 'unplugin-vue-components/resolvers'\nimport { createSvgIconsPlugin } from 'vite-plugin-svg-icons'\nimport AutoImport from 'unplugin-auto-import/vite'\nimport UnoCSS from 'unocss/vite'\nimport { createHtmlPlugin } from 'vite-plugin-html'\nimport path from 'path'\n\n// https://vitejs.dev/config/\nexport default defineConfig(({ mode }: ConfigEnv) => {\n    const env = loadEnv(mode, process.cwd())\n    return {\n        // 配置插件\n        plugins: [\n            vue(),\n            eslint(),\n            /** 打包分析插件，官网：https://github.com/btd/rollup-plugin-visualizer */\n            visualizer({\n                // 注意这里要设置为true，打包时会自动打开分析页面。\n                open: true,\n                // 分析图生成的文件名\n                filename: 'stats.html',\n                // 收集gzip大小并将其显示\n                gzipSize: true, //\n                // 收集 brotli 大小并将其显示\n                brotliSize: true\n            }),\n            /** 打包压缩插件 官网：https://github.com/vbenjs/vite-plugin-compression */\n            ViteCompression({ algorithm: 'gzip' }),\n            // 自动导入Composition API,https://github.com/antfu/unplugin-auto-import\n            AutoImport({\n                // dts生成路径\n                dts: 'src/types/auto-import.d.ts',\n                // 自动本地导入文件目录路径\n                dirs: ['src/store/modules'],\n                // 设置第三方自动导入的包名\n                imports: [\n                    'vue',\n                    'vue-router',\n                    'pinia',\n                    '@vueuse/core',\n                    {\n                        'naive-ui': ['useDialog', 'useMessage', 'useNotification', 'useLoadingBar'],\n                        alova: ['useRequest', 'createAlova'],\n                        '@/service/alova': ['alova']\n                    }\n                ]\n            }),\n            // 自动导入组件，https://github.com/antfu/unplugin-vue-components\n            Components({\n                dts: 'src/types/components.d.ts',\n                dirs: ['src/components'],\n                resolvers: [NaiveUiResolver()]\n            }),\n            // 本地svg动态加载插件 官网地址：https://github.com/vbenjs/vite-plugin-svg-icons\n            createSvgIconsPlugin({\n                iconDirs: [path.resolve(process.cwd(), 'src/assets/svg')],\n                symbolId: 'icon-local-[dir]-[name]',\n                inject: 'body-last',\n                customDomId: '__SVG_ICON_LOCAL__'\n            }),\n            // 官网地址:https://unocss.dev/integrations/vite\n            UnoCSS(),\n            // 在html中创建ejs标签，官网地址：https://github.com/vbenjs/vite-plugin-html/blob/main/README.zh_CN.md\n            createHtmlPlugin({\n                // 是否压缩 html\n                minify: true,\n                /**\n                 * 需要注入 index.html ejs 模版的数据\n                 */\n                inject: {\n                    data: {\n                        title: env.VITE_SYSTEM_TITLE,\n                        description: env.VITE_SYSTEM_DESC,\n                        keywords: env.VITE_SYSTEM_KEYWORDS\n                    }\n                }\n            })\n        ],\n        resolve: {\n            // 配置别名\n            alias: [{ find: '@', replacement: path.resolve(__dirname, 'src') }]\n        },\n        // 本地运行配置，及跨域反向代理配置\n        server: {\n            // 服务器端口\n            port: 9527,\n            // 默认启用并允许任何源\n            cors: true,\n            // 在服务器启动时自动在浏览器中打开应用程序\n            open: true,\n            // 反向代理配置，注意rewrite写法，开始没看文档在这里踩了坑\n            proxy: {\n                // 本地开发环境通过代理实现跨域，生产环境使用nginx转发\n                '/api': {\n                    // 通过代理接口访问实际地址。这里是实际访问的地址。vue会通过代理服务器来代理请求\n                    target: env.VITE_BASIC_API_URL,\n                    changeOrigin: true,\n                    // 允许websocket代理\n                    ws: true,\n                    // 将api替换为空\n                    rewrite: (path) => path.replace(/^\\/api/, '/api')\n                }\n            }\n        }\n    }\n})\n```\n\n### 2 Naive-UI框架\n> 官网地址：https://www.naiveui.com/zh-CN/os-theme/docs/installation\n\n`naive-ui`全量使用`TypeScript`编写, 无样式文件，组件按需加载，是一个使用起来非常`清爽`的`Vue 3`组件库, 组件比较完整，主题可调，完全兼容现在主流的浏览器。\n\n#### 1 安装依赖\n```shell\npnpm install naive-ui -D\n```\n#### 2 按需引入\n可以使用`unplugin-auto-import` 插件来自动导入`API`,使用`unplugin-vue-components`插件来按需自动加载组件，插件会自动解析模板中的使用到的组件，并导入组件。\n\n1 在`vite.config.ts`中进行配置，代码如下：\n```js\nimport AutoImport from 'unplugin-auto-import/vite'\nimport Components from 'unplugin-vue-components/vite'\nimport { NaiveUiResolver } from 'unplugin-vue-components/resolvers'\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [\n    vue(),\n    AutoImport({\n      imports: [\n        'vue',\n        {\n          'naive-ui': [\n            'useDialog',\n            'useMessage',\n            'useNotification',\n            'useLoadingBar'\n          ]\n        }\n      ]\n    }),\n    Components({\n      resolvers: [NaiveUiResolver()]\n    })\n  ]\n})\n```\n2 如果你在使用`Volar`，那么可以在`tsconfig.json`中配置`compilerOptions.types`来指定全局组件类型\n```js\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    // ...\n    \"types\": [\"naive-ui/volar\"]\n  }\n}\n```\n至此`naive-ui`按需导入成功，此时便可以使用相关组件进行开发，详情参考：[naive-ui官网](https://www.naiveui.com/zh-CN/os-theme/docs/installation)\n\n\n### 3 Unocss引擎\n> 官方网站：https://unocss.dev/\n\n`UnoCSS` - 一个具有高性能且极具灵活性的即时原子化`CSS`引擎，而非一款框架，因为它并未提供核心工具类，所有功能可以通过预设和内联配置提供，目前内置的`presetUno`预设涵盖了[Tailwindcss](https://www.tailwindcss.cn/)和[Windicss](https://cn.windicss.org/)的大部分功能，熟悉上面2个原子css框架写法的人，上手很容易，`UnoCSS`的主要目标是直观性和可定制性。\n#### 3.1 依赖安装\n```shell\npnpm install unocss  -D\n```\n#### 3.2 引擎配置\n在`vite.config.ts`增加如下配置，相关配置参考：[unocss](https://unocss.dev/integrations/vite)\n```ts\n// vite.config.ts\nimport UnoCSS from 'unocss/vite'\nimport { defineConfig } from 'vite'\nexport default defineConfig({\n  plugins: [\n    ...\n    UnoCSS(),\n    ...\n  ],\n})\n```\n#### 3.2 创建uno.config.ts\n在项目根目录下面创建`uno.config.ts`,增加如下配置：\n```ts\n//uno.config.ts\nimport { defineConfig, presetUno, presetAttributify } from 'unocss'\nexport default defineConfig({\n    //预设配置参考：https://unocss.dev/presets\n    presets: [\n        //设置默认预设，当自定义其他预设后，默认预设需要额外添加\n        presetUno({ dark: \"class\" }),\n        //设置归因预设(Attributify preset),可以使用bg=red等语法\n        presetAttributify()\n    ],\n    //设置shortcuts,只能使用预设的和自定义的规则\n    shortcuts: {\n        'wh-full': 'w-full h-full',\n        'flex-row-center': 'flex justify-center items-center',\n        'flex-row-between': 'flex justify-between items-center',\n        'flex-row-evenly': 'flex justify-evenly items-center',\n        'flex-row-warp': 'flex flex-wrap',\n        'flex-row-end': 'flex justify-end items-center',\n        'flex-col-center': 'flex flex-col justify-center items-center',\n        'flex-x-center': 'flex justify-center',\n        'flex-y-center': 'flex items-center',\n        'i-flex-center': 'inline-flex justify-center items-center',\n        'i-flex-x-center': 'inline-flex justify-center',\n        'i-flex-y-center': 'inline-flex items-center'\n    },\n    //自定义规则\n    rules: [],\n    //主题配置\n    theme: {\n        //继承boxShadow\n        boxShadow: {\n            box: '0 1px 8px 0 rgba(255, 0, 0, 0.1)',\n            item: \"0 1px 8px 0 rgba(0, 0, 0, 0.1)\"\n        },\n        colors: {\n            primary: 'rgb(var(--primary-color))',\n            primary_hover: 'var(--primary-color-hover)',\n            primary_pressed: 'var(--primary-color-pressed)',\n            primary_active: 'var(--primary-color-active)',\n            info: 'var(--info-color)',\n            info_hover: 'var(--info-color-hover)',\n            info_pressed: 'var(--info-color-pressed)',\n            info_active: 'var(--info-color-active)',\n            success: 'var(--success-color)',\n            success_hover: 'var(--success-color-hover)',\n            success_pressed: 'var(--success-color-pressed)',\n            success_active: 'var(--success-color-active)',\n            warning: 'var(--warning-color)',\n            warning_hover: 'var(--warning-color-hover)',\n            warning_pressed: 'var(--warning-color-pressed)',\n            warning_active: 'var(--warning-color-active)',\n            error: 'var(--error-color)',\n            error_hover: 'var(--error-color-hover)',\n            error_pressed: 'var(--error-color-pressed)',\n            error_active: 'var(--error-color-active)'\n        }\n    }\n})\n```\n上面是我项目中经常使用到的配置。\n\n#### 3.3 配置virtual:uno.css\n在`main.ts`中增加如下代码：\n```ts\n// main.ts\nimport 'virtual:uno.css'\n```\n#### 3.4 VScode插件安装\n`VScode`插件市场有`Unocss`插件，安装以后鼠标放上去可以查看对应`class`的`css`属性和值信息，[点我安装插件](https://marketplace.visualstudio.com/items?itemName=antfu.unocss)\n\n### 4 Pinia状态管理\n> 官网：https://pinia.vuejs.org/\n\n`Pinia`是`Vue`的存储库，它允许您跨组件/页面共享状态，与`vuex`功能类似，不仅兼容`Option API`写法也兼容`Composition API`写法，同时也只是插件扩展。\n\n#### 4.1 依赖安装\n```shell\npnpm install pinia\n```\n#### 4.2 配置Pinia实例\n1、在`vite.config.ts`文件的`AutoImport`自动导入插件中，增加`pinia`API自动导入。\n```ts\nexport default defineConfig(({ mode }: ConfigEnv) => {\n  return {\n    plugins: [\n      ...\n      //自动导入Composition API,https://github.com/antfu/unplugin-auto-import\n      AutoImport({\n        dts: \"src/types/auto-import.d.ts\",\n        imports: [\n          ...\n          + \"pinia\",\n          ...\n        ],\n      })\n      ...\n    ]\n  }\n})\n```\n配置了`pinia`API自动导入后，`defineStore`和`createPinia`无需导入，便可以直接使用。\n\n2 在项目`src`目录下创建`store`目录，创建`index.ts`文件，配置`pinia`实例。\n```ts\n//src/store/index.ts\nimport type { App } from 'vue';\n/**\n * 安装vue状态管理插件pinia\n * @param app \n */\nexport function setupStore(app: App) {\n    const pinia = createPinia();\n    //挂载pinia实例到app\n    app.use(pinia);\n}\n```\n3 在`main.ts`中注册`pinia`实例插件。\n```ts\n//main.ts\nimport { createApp } from 'vue'\nimport './style.css'\nimport 'virtual:uno.css'\n+ import { setupStore } from './store';\nimport App from './App.vue'\nconst setupApp = async () => {\n    //创建vue实例\n    const app = createApp(App)\n    //创建pinia\n    + setupStore(app);\n    //挂载app\n    app.mount('#app');\n}\nsetupApp()\n```\n到此为止，`pinia`实例创建好了，并挂载在了`vue`实例上。\n\n4 创建`src/store/modules`目录，将状态管理文件按照模块放在`src/store/modules`目录中。建议使用`Composition API`写法进行开发。下面是个简单例子:\n```ts\n//src/store/modules/demo.ts\nexport const useCounterStore = defineStore('counter', () => {\n    const count = ref(0)\n    const increment = (): void => {\n        count.value++\n    }\n    return { count, increment }\n})\n```\n请注意，`store`是一个用`reactive`包裹的对象，这意味着不需要在`getter`之后写`.value`，但是，就像`setup` 中的`props` 一样，我们不能对其进行解构：\n```ts\nexport default defineComponent({\n  setup() {\n    const store = useStore()\n    // ❌ 这不起作用，因为它会破坏响应式\n    // 这和从 props 解构是一样的\n    const { name, doubleCount } = store\n\n    name // \"eduardo\"\n    doubleCount // 2\n\n    return {\n      // 一直会是 \"eduardo\"\n      name,\n      // 一直会是 2\n      doubleCount,\n      // 这将是响应式的\n      doubleValue: computed(() => store.doubleCount),\n      }\n  },\n})\n```\n为了从`Store`中提取属性同时保持其响应式，您需要使用`storeToRefs()`。 它将为任何响应式属性创建 `refs`。 当您仅使用`store`中的状态但不调用任何操作时，这很有用：\n```ts\nimport { storeToRefs } from 'pinia'\nexport default defineComponent({\n  setup() {\n    const store = useStore()\n    // `name` 和 `doubleCount` 是响应式引用\n    // 这也会为插件添加的属性创建引用\n    // 但跳过任何 action 或 非响应式（不是 ref/reactive）的属性\n    const { name, doubleCount } = storeToRefs(store)\n\n    return {\n      name,\n      doubleCount\n    }\n  },\n})\n```\n\n5 将模块目录`modules`下面的文导出到`src/store/modules/index.ts`文件中，这样我们以后使用的时候，可以直接从`@/store/modules`直接导入\n```ts\n//src/store/modules/index.ts\nexport * from './demo'\n//src/store/index.ts\nexport * from './modules'\n```\n5 在需要调用的文件中，通过命令导入`import { useCounterStore } from '@/store/modules'`,使用方法如下：\n```ts\nimport { useCounterStore } from '@/store/modules'\nconst counter = useCounterStore()\nconst { count } = storeToRefs(counter)\n```\n注意，不能直接对`useCounterStore()`进行结构，会影响响应性，需要用`storeToRefs`进行包装，然后就可以在模板中使用`count`和`increment`了。\n\n6 `AutoImport`设置自动导入\n\n虽然经过上面的配置，我们可以通过`import { useCounterStore } from '@/store/modules'`在需要的文件中进行导入使用，但每次都要写就显的麻烦，可以通过功能强大的`AutoImport`插件帮我们自动导入，以后就可以直接使用`useCounterStore`,就不用导入了。\n\n在`vite.config.ts`文件的`AutoImport`自动导入插件中，增加`src/store/modules`目录API的自动导入。\n```ts\nexport default defineConfig(({ mode }: ConfigEnv) => {\n  return {\n    plugins: [\n      ...\n      //自动导入Composition API,https://github.com/antfu/unplugin-auto-import\n      AutoImport({\n        dts: \"src/types/auto-import.d.ts\",\n        // 自动本地导入文件目录路径\n        + dirs: ['src/store/modules'],\n        imports: [\n          ...\n          \"pinia\",\n          ...\n        ],\n      })\n      ...\n    ]\n  }\n})\n```\n到此，便可以愉快的玩耍了:smile: \n#### 4.3 状态持久化\n`pinia`支持插件扩展，增强自身功能。类似`vuex`一样，`pinia`也有状态持久化插件`pinia-plugin-persistedstate`,帮助`pinia`完成状态持久功能，支持`localStorage`和`sessionStorage`2种持久化方式。\n> 官网: https://prazdevs.github.io/pinia-plugin-persistedstate/guide/\n\n##### 4.3.1 依赖安装\n```shell\npnpm install pinia-plugin-persistedstate\n```\n##### 4.3.2 插件配置\n1 在`src/store/`目录下面创建文件目录`plugins`, 将插件`pinia-plugin-persistedstate`配置代码放在`src/store/plugin/modules/persistedstate.ts`中。\n```ts\n// src/store/plugin/modules/persistedstate.ts\n// 参考地址：https://prazdevs.github.io/pinia-plugin-persistedstate/guide/\nimport { createPersistedState } from 'pinia-plugin-persistedstate'\nimport { encrypto, decrypto } from '@/utils'\n/**\n * pinia 全局持久化配置，会覆盖默认配置，但也会被单个store的persist配置覆盖\n */\nexport const createPersistedStatePlugins = createPersistedState({\n    storage: sessionStorage,\n    beforeRestore: (context) => {\n        console.log(context)\n        return context\n    },\n    afterRestore: (context) => {\n        console.log(context)\n        return context\n    },\n    // 设置序列化，生产加密，开发采用默认不加密\n    serializer: {\n        serialize: import.meta.env.PROD ? encrypto : JSON.stringify,\n        deserialize: import.meta.env.PROD ? decrypto : JSON.parse\n    }\n})\n```\n`serializer`默认的序列化为`JSON.stringify`,反序列化为`JSON.parse`，开发期间为了便于观察数据，采用默认的序列化方式，生成环境采用`encrypto`和`decrypto`进行加密和解密，增加数据的安全性。更多具体配置，请查看[官方文档](https://prazdevs.github.io/pinia-plugin-persistedstate/guide/)\n\n2 将配置好的插件安装在`pinia`实例上面，配置如下：\n```ts\nimport type { App } from 'vue'\n+ import { createPersistedStatePlugins } from './plugins'\n/**\n * 安装vue状态管理插件pinia\n * @param app\n */\nexport function setupStore(app: App): void {\n    // 创建pinia实例\n    const pinia = createPinia()\n    // 挂载pinia数据持久化插件\n    + pinia.use(createPersistedStatePlugins)\n    // 挂载pinia实例到app\n    app.use(pinia)\n}\n```\n3 开启持久化设置，在`store`状态文件增加如下配置,开启持久化配置，默认不开启。以文件`src/store/modules/demo.ts`举例：\n```ts\nexport const useCounterStore = defineStore(\n    'counter',\n    () => {\n        const count = ref(0)\n        const increment = (): void => {\n            count.value++\n        }\n        return { count, increment }\n    },\n    {\n       + persist: true\n    }\n)\n\n```\n到此，`pinia`状态持久化配置完毕了，持久化状态便会生效。\n\n### 5 Vue Router路由\n`Vue Router`为`vue`项目提供路由导航功能。\n> 官网：https://router.vuejs.org/zh/\n\n#### 5.1 依赖安装\n`vue3`请安装`vue-router@4`版本路由。\n```shell\npnpm install  vue-router@4\n```\n#### 5.2 路由配置\n1 项目`src`目录下新建`router`目录，并进行基础的路由配置，具体路由模块文件根据实际开发自行增加配置。\n```ts\n// src/router/index.ts\nimport type { App } from 'vue'\nimport { createRouter, createWebHistory, createWebHashHistory } from 'vue-router'\n\n// 获取路由模式(history和hash)和项目baseUrl\nconst { VITE_HASH_ROUTE = 'false', VITE_BASE_URL } = import.meta.env\n\n/**\n * 定义返回模块\n */\nexport const router = createRouter({\n    history: VITE_HASH_ROUTE === 'true' ? createWebHashHistory(VITE_BASE_URL) : createWebHistory(VITE_BASE_URL),\n    routes: []\n})\n\n/**\n * 路由安装插件，暴露方法在main.ts中进行安装\n * @param app\n */\nexport async function setupRouter(app: App): Promise<void> {\n    app.use(router)\n    await router.isReady()\n}\n```\n2 在`main.ts`中进行路由安装\n```ts\n// main.ts\nimport { createApp } from 'vue'\nimport './style.css'\nimport 'virtual:uno.css'\n+ import { setupRouter } from './router'\nimport { setupStore } from './store'\nimport App from './App.vue'\nconst setupApp = async (): Promise<void> => {\n    // 创建vue实例\n    const app = createApp(App)\n    // 创建pinia\n    setupStore(app)\n    // 创建vueRouter\n    + await setupRouter(app)\n    // 挂载app\n    app.mount('#app')\n}\nawait setupApp()\n```\n3 在`vite.config.ts`的API自动导入插件`AutoImport`，增加以下配置：\n```ts\n // vite.config.ts\n ...\n AutoImport({\n    // dts生成路径\n    dts: 'src/types/auto-import.d.ts',\n    // 自动本地导入文件目录路径\n    dirs: ['src/store/modules'],\n    // 设置第三方自动导入的包名\n    imports: [\n        'vue',\n        'pinia',\n        +'vue-router',\n        {\n            'naive-ui': ['useDialog', 'useMessage', 'useNotification', 'useLoadingBar']\n        }\n    ]\n}),\n...\n```\n到此，路由安装配置完毕。\n\n### 6 Alova数据请求\n> 官网：https://alova.js.org/zh-CN/get-started/overview\n\n`alova`是一个量级的请求策略库，它针对不同请求场景分别提供了具有针对性的请求策略，来提升应用可用性、流畅性，降低服务端压力，让应用如智者一般具备卓越的策略思维。alova 核心模块提供了各类适配器接口、中间件机制来保证高扩展能力，从而实现更多的请求场景。\n\n#### 6.1 依赖安装\n```shell\npnpm install alova\n```\n#### 6.2 依赖配置\n在项目根目录创建`service/alova/index.ts`文件，代码配置如下：\n```ts\nimport GlobalFetch from 'alova/GlobalFetch'\nimport VueHook from 'alova/vue'\n\n// 1. 创建alova实例\nexport const alova = createAlova({\n    /** base地址 */\n    baseURL: '',\n    /** 请求超时时间 */\n    timeout: 10000,\n    // VueHook用于创建ref状态，包括请求状态loading、响应数据data、请求错误对象error等\n    statesHook: VueHook,\n    // 请求适配器，推荐使用fetch请求适配器\n    requestAdapter: GlobalFetch(),\n    /** 全局的请求前置钩子 */\n    beforeRequest: (config) => {\n        console.log(config)\n    },\n    // 全局的响应拦截器\n    responded: async (response) => {\n        console.log(response)\n        return await response.json()\n    }\n})\n```\n#### 6.3 自动导入配置\n在`vite.config.ts`的`AutoImport`增加如下配置：\n```ts\n//vite.config.ts\n...\nAutoImport({\n    // dts生成路径\n    dts: 'src/types/auto-import.d.ts',\n    // 自动本地导入文件目录路径\n    dirs: ['src/store/modules'],\n    // 设置第三方自动导入的包名\n    imports: [\n        'vue',\n        'vue-router',\n        'pinia',\n        '@vueuse/core',\n        {\n            'naive-ui': ['useDialog', 'useMessage', 'useNotification', 'useLoadingBar'],\n            + alova: ['useRequest', 'createAlova'],\n            +'@/service/alova': ['alova']\n        }\n    ]\n}),\n...\n```\n#### 6.4 使用例子\n```ts\nconst { loading, data, send: sendRequest } = useRequest(alova.Get('/api/weather/city/101030100'), { immediate: false })\nconst handlerEvent = async (): Promise<void> => {\n    await sendRequest()\n}\n```\n### 7 工具包依赖\n下面介绍项目中集成的几个工具包。\n#### 7.1 @vueuse/core\n> 官网：https://vueuse.org/\n\n`@vueuse/core`是一个强大的工具包，包含大量的`Composition API`工具，支持`vue2`和`vue3`,你想不到的工具都在这里，非常实用。\n##### 7.1.1 依赖安装\n```shell\npnpm install @vueuse/core\n```\n##### 7.1.2 配置自动导入\n在`vite.config.ts`的API自动导入插件`AutoImport`，增加以下配置：\n```ts\n // vite.config.ts\n ...\n AutoImport({\n    // dts生成路径\n    dts: 'src/types/auto-import.d.ts',\n    // 自动本地导入文件目录路径\n    dirs: ['src/store/modules'],\n    // 设置第三方自动导入的包名\n    imports: [\n        'vue',\n        'vue-router',\n        'pinia',\n        +'@vueuse/core',\n        {\n            'naive-ui': ['useDialog', 'useMessage', 'useNotification', 'useLoadingBar']\n        }\n    ]\n}),\n...\n```\n#### 7.2 crypto-js\n> 官网：https://github.com/brix/crypto-js\n\n`crypto-js`是一个比较古老的加解密工具，代码仓库都是十年前的，但功能还是很强大。\n\n##### 7.2.1 依赖安装\n```shell\n# 安装crypto-js 依赖\npnpm install crypto-js\n# 安装crypto-js类型声明文件\npnpm install @types/crypto-js -D\n```\n##### 7.2.2 简单示例\n简单的使用例子参考：`src/utils/modules/crypto/index.ts`，更加详细使用方法参考：[官网](https://github.com/brix/crypto-js)\n\n#### 7.3 lodash-es\n> 官网：https://www.lodashjs.com/\n\n`Lodash`是一个一致性、模块化、高性能的`JavaScript`实用工具库，算是从`Underscore`分离出来的超集.\n`lodash` 为了良好的浏览器兼容性，它使用了旧版`es5` 的模块语法；而`lodash-es`则使用了`es6 `的模块语法，这让`vite`之类的打包工具可以对其进行`tree shake （摇树优化）`以删除未使用的代码来优化打包体积。所以在使用`lodash`库时，推荐通过`lodash-es`来进行导入操作。`lodash-es`提供了很多实用的工具，比如：节流，防抖，深拷贝等。\n##### 7.3.1 依赖安装\n```shell\n# 安装lodash-es依赖\npnpm install lodash-es\n# 安装lodash-es类型声明文件\npnpm install @types/lodash-es -D\n```\n##### 7.3.2 简单示例\n1 导入方式\n```ts\n/*引入全部*/\nimport _ from 'lodash-es';\n/**按需引入*/\nimport { defaultsDeep } from 'lodash-es'; \n```\n2 浅拷贝clone\n```ts\nimport { clone } from 'lodash-es'; \nconst objects = [{ 'a': 1 }, { 'b': 2 }]; \nconst shallow = clone(objects);\n // true\nconsole.log(shallow[0] === objects[0]); \n```\n3 深拷贝 cloneDeep\ncloneDeep(value) 类似clone 但是它会递归拷贝 value。返回拷贝后的值。\n```ts\nimport { cloneDeep } from 'lodash-es';\nconst objects = [{ 'a': 1 }, { 'b': 2 }];\nconst deep = cloneDeep(objects);\n//false\nconsole.log(deep[0] === objects[0]); \n```\n4 防抖 debounce\ndebounce(func, [wait=0], [options=]) 创建一个 debounced（防抖动）函数，该函数会从上一次被调用后，延迟 wait 毫秒后调用 func 方法。 返回新的 debounced（防抖动）函数。\n- func (Function): 要防抖动的函数。\n- [wait=0] (number): 需要延迟的毫秒数。\n- [options=] (Object): 选项对象。\n- [options.leading=false] (boolean): 指定在延迟开始前调用。\n- [options.maxWait] (number): 设置 func 允许被延迟的最大值。\n- [options.trailing=true] (boolean): 指定在延迟结束后调用。\n```ts\nimport { debounce } from 'lodash-es';\n// 避免窗口在变动时出现昂贵的计算开销。\njQuery(window).on('resize',debounce(calculateLayout, 150));\n \n// 当点击时 `sendMail` 随后就被调用。\njQuery(element).on('click',debounce(sendMail, 300, {\n  'leading': true,\n  'trailing': false\n}));\n \n// 确保 `batchLog` 调用1次之后，1秒内会被触发。\nvar debounced = debounce(batchLog, 250, { 'maxWait': 1000 });\nvar source = new EventSource('/stream');\njQuery(source).on('message', debounced);\n \n// 取消一个 trailing 的防抖动调用\njQuery(window).on('popstate', debounced.cancel);\n```\n5 节流 throttle\nthrottle(func, [wait=0], [options=]) 创建一个节流函数，在 wait 秒内最多执行 func 一次的函数。 返回节流的函数。\n- func (Function): 要节流的函数。\n- [wait=0] (number): 需要节流的毫秒。\n- [options=] (Object): 选项对象。\n- [options.leading=true] (boolean): 指定调用在节流开始前。\n- [options.trailing=true] (boolean): 指定调用在节流结束后。\n```ts\n// 避免在滚动时过分的更新定位\njQuery(window).on('scroll', throttle(updatePosition, 100));\n \n// 点击后就调用 `renewToken`，但5分钟内超过1次。\nvar throttled = throttle(renewToken, 300000, { 'trailing': false });\njQuery(element).on('click', throttled);\n \n// 取消一个 trailing 的节流调用。\njQuery(window).on('popstate', throttled.cancel);\n```\n\n## 四 代码规范\n下面开始集成项目多人协作开发过程中，代码编写规范，格式化规范以及git提交规范，统一团队开发标准，规范代码风格。\n### 1 Eslint\n\n> Eslint 中文官网地址：<https://zh-hans.eslint.org/docs/latest/use/getting-started>   \n> Eslint Github地址：<https://github.com/eslint/eslint>\n\nESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。不管是多人合作还是个人项目，代码规范是很重要的。这样做不仅可以很大程度地避免基本语法错误，也保证了代码的可读性。这所谓工欲善其事，必先利其器。\n\n#### 1.1 VScode启用Eslint\n\n1 在`vscode`中启用`Eslint`插件是必须的，它可以在编写代码时自动检测和手动修复。如果没有安装插件，[点我安装](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)。\n\n2 插件的扩展设置。选择`VSCode`左下角的“设置”， 打开`VSCode` 配置文件,添加如下配置:\n\n```json\n// 是否开启eslint\n\"eslint.enable\": true,\n// code代码保存时，自动eslint修复\n\"editor.codeActionsOnSave\": {\n    \"source.fixAll.eslint\": true,\n    \"eslint.autoFixOnSave\" : true\n}\n```\n\n添加后,这样每次保存的时候就可以根据根目录下`.eslintrc.cjs`你配置的`ESLint`规则来检查和做一些简单的`fix`，如果未生效，重启`VScode`\n\n同样也可以不在`VScode`编辑器全局进行配置，只在项目中进行配置，参考项目目录`.vscode`中`setting.json`的配置。\n\n#### 1.2 Eslint依赖安装\n\n1 `Eslint`安装方式有2种，一种是直接安装依赖包，另一种就是通过命令进行`npm init @eslint/config`进行`Eslint`初始化,建议采用第2种，不容易漏掉相关依赖。执行结果如下：\n\n![](https://cdn.staticaly.com/gh/AnyFork/blog-images/main/markdown/202307201715868.png)\n\n2 安装完成后，项目目录下会自动生成`.eslintrc.cjs`文件，注意:文件后缀为`cjs`非`js`,文件初始化内容如下：\n\n```js\nmodule.exports = {\n    env: {\n        browser: true,\n        es2021: true,\n        node: true\n    },\n    extends: ['standard-with-typescript', 'plugin:vue/vue3-essential'],\n    overrides: [\n        {\n            env: {\n                node: true\n            },\n            files: ['.eslintrc.{js,cjs}'],\n            parserOptions: {\n                sourceType: 'script'\n            }\n        }\n    ],\n    parserOptions: {\n        ecmaVersion: 'latest',\n        sourceType: 'module'\n    },\n    plugins: ['vue'],\n    rules: {}\n}\n```\n\n3 `.eslintrc.cjs`文件配置 `ESLint Plugin Vue` 则是专门为`Vue.js`项目中的代码提供支持的插件。这个插件可以帮助我们检查`Vue.js`组件中的代码规范、避免常见的错误以及优化代码性能,参照[eslint-plugin-vue](https://eslint.vuejs.org/user-guide/)官网配置文档，需要对`.eslintrc.cjs`增加如下配置：\n\n```js\nmodule.exports = {\n  ...\n  overrides: [\n  ],\n  + parser: 'vue-eslint-parser',\n  parserOptions: {\n    + parser: '@typescript-eslint/parser',\n    ...\n  },\n  ...\n}\n```\n\n上面增加的解析器用于解析`vue`和`typeScript`相关的`Eslint`校验规则。\n\n至此，项目中的`Eslint`已经起作用了，如果无效，请查看vscode上是否已安装`Eslint`插件，如果没有，[点击安装](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)。\n\n#### 1.3 script检测脚本安装\n\n我们可以通过命令进行`Eslint`规范检测和修复。执行以下命令在`package.json`中生成检测命令。\n\n```shell\n//eslint检测命令\npnpm pkg set scripts.lint=\"eslint . --ext src/*.{js,ts,vue}\"\n//eslint修复命令\npnpm pkg set scripts.lint:fix=\"eslint . --ext src/*.{js,ts,vue} --fix\"\n```\n\n完成上面的步骤，我们可以通过`pnpm lint`检测规则，`pnpm lint:fix`修复简单的校验错误，但都是手动触发，不太方便，下面介绍一款插件，能够集成`Vite`中使用，在项目运行核打包时进行`Eslint`规则校验。\n\n#### 1.4 Vite插件配置\n\n> 官网：<https://github.com/gxmari007/vite-plugin-eslint>\n\n`vite-plugin-eslint`用于配置`vite`在运行和打包的时候，自动检测`eslint`规范，如果不符合规范，在项目启动时不会报错，浏览器打开页面或者页面刷新时会报`eslint`检测错误。\n\n刚开始使用的时候，明明运行没有报错，一度怀疑插件有问题，直到打开浏览器进行访问，页面和控制台才出现`Eslint`规则校验错误，走了好的弯路。\n\n1 安装插件依赖\n\n```shell\npnpm install vite-plugin-eslint -D\n```\n\n2 在`vite.config.ts`配置插件\n\n```ts\nimport { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\n// 该包是用于配置vite运行的时候自动检测eslint规范,不符合规范，启动时不会报错，页面刷新时会报错，https://github.com/gxmari007/vite-plugin-eslint\nimport eslint from 'vite-plugin-eslint'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n    plugins: [vue(), eslint()]\n})\n```\n\n#### 1.5 常见问题\n\n经过上面的配置后，当我们通过`pnpm dev`运行项目时,会出现以下几个问题。\n\n错误①:`@typescript-eslint/dot-notation`\n\n```log\nError: Error while loading rule '@typescript-eslint/dot-notation': You have used a rule which requires parserServices to be generated. You must therefore provide a value for the \"parserOptions.project\" property for @typescript-eslint/parser.\n```\n\n方案：\n\n1 在`.eslintrc.cjs`增加以下配置\n\n```js\nmodule.exports = {\n  ...\n  parserOptions: {\n    + project: [\"./tsconfig.json\"],\n    ...\n  },\n  ...\n}\n```\n\n2 在`.tsconfig.json`文件的`include`选项中增加`.eslintrc.cjs`配置\n\n```js\nmodule.exports = {\n  ...\n   + \"include\": [\".eslintrc.cjs\"],\n  ...\n}\n```\n\n错误2：`<tsconfigRootDir>/vite.config.ts`\n\n```log\nerror  Parsing error: ESLint was configured to run on `<tsconfigRootDir>/vite.config.ts` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.json\nHowever, that TSConfig does not include this file. Either:\n```\n\n方案：\n\n1 在`.tsconfig.json`文件的`include`选项中增加`vite.confit.ts`配置\n\n```js\nmodule.exports = {\n  ...\n   + \"include\": [\"vite.confit.ts\"],\n  ...\n}\n```\n\n错误3：`@typescript-eslint/triple-slash-reference`\n\n```log\nC:\\Users\\Administrator\\Desktop\\vite-standard-template\\src\\vite-env.d.ts\n  1:1  error  Do not use a triple slash reference for vite/client, use `import` style instead  @typescript-eslint/triple-slash-reference\n```\n\n方案：\n\n1 直接在`vite-env.d.ts`中忽略`///`引用规则校验\n\n```ts\n/* eslint-disable @typescript-eslint/triple-slash-reference */\n/// <reference types=\"vite/client\" />\n```\n\n2 或者修改`.eslintrc.cjs`校验规则\n\n```js\nmodule.exports = {\n   ...\n    rules: {\n        // 关闭下面/// <reference path=\"...\" />, /// <reference types=\"...\" />,  /// <reference lib=\"...\" /> 校验\n        '@typescript-eslint/triple-slash-reference': 'off'\n    }\n    ...\n}\n```\n\n错误4：`parserOptions.extraFileExtensions`\n\n```log\n error  Parsing error: ESLint was configured to run on `<tsconfigRootDir>/src\\App.vue` using `parserOptions.project`: <tsconfigRootDir>/tsconfig.json\nThe extension for the file (`.vue`) is non-standard. You should add `parserOptions.extraFileExtensions` to your config\n```\n\n方案：\n\n1 在`.eslintrc.cjs`增加以下配置\n\n```js\nmodule.exports = {\n  ...\n  parserOptions: {\n    + extraFileExtensions: ['.vue'],\n    ...\n  },\n  ...\n}\n```\n\n到此为止，所有错误处理完毕。如果编辑器依然爆红，重启一下`vscode`即可。\n\n#### 1.6 配置eslintignore\n\n`.eslintignore`文件是`Eslint`校验规则忽略文件，与`.gitignore`功能类似。项目中创建`.eslintignore`,填写需要忽略校验的文件\n\n```js\n*.sh\nnode_modules\n*.md\n*.woff\n*.ttf\n.vscode\ndist\npublic\n.husky\n```\n\n### 2 Perttier\n\n> 官网：<https://www.prettier.cn/>\n\n`Perttier`是一个功能强大的代码格式化工具，支持多种格式的文件类型，还能保存就格式化,支持需要编程语言。`VScode`提供了强大的`Prettier`插件，[点我安装](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode),安装完插件，便可以愉快的玩耍了。\n\n#### 2.1 Perttier与Eslint区别\n\n1、`Eslint`针对的是`javascript`，他是一个检测工具，包含js语法以及少部分格式问题，在`Eslint`看来，语法对了就能保证代码正常允许，格式问题属于其次；2、`prettier`属于格式化工具，它看不惯格式不统一，所以它就把`Eslint`没干好的事接着干，另外`prettier`支持包含js在内的**多种语言**\n\n总结：`Eslint`和`prettier`这俩兄弟一个保证js代码质量，一个保证代码美观。共同点就是标准化代码规范。\n\n#### 2.2 依赖安装\n\n1 `Eslint`搭配`prettier`使用步骤,首先安装插件`eslint-config-prettier`和`eslint-plugin-prettier`\n\n```shell\npnpm install  eslint-plugin-prettier prettier eslint-config-prettier -D\n```\n\n2 其次配置`.eslintrc.cjs`文件,增加如下配置：\n\n```js\nmodule.exports = {\n  ...\n  + extends: [\"plugin:prettier/recommended\"]\n  ...\n}\n```\n\n如果有其他扩展，则`plugin:prettier/recommended`放在最后.\n\n3 创建`.prettierrc.cjs`文件，可以新增规则，对`.eslintrc.cjs`的`rules`进行覆盖，常用配置如下：\n\n```js\nmodule.exports = {\n    // 指定每个缩进级别的空格数<int>，默认2\n    tabWidth: 4,\n    // 用制表符而不是空格缩进行<bool>，默认false\n    useTabs: false,\n    //一行的字符数，如果超过会进行换行，默认为80\n    printWidth: 300,\n    //字符串是否使用单引号，默认为false，使用双引号\n    singleQuote: true,\n    //避免报错delete (cr)的错\n    endOfLine: 'auto',\n    // 换行,always：超过printWidth就换行，never：不换行，preserve：按照原样处理\n    proseWrap: 'always',\n    // 不加分号\n    semi: false,\n    // 结尾处不加逗号\n    trailingComma: 'none',\n    // 忽略'>'下落问题\n    htmlWhitespaceSensitivity: 'ignore'\n}\n```\n\n这里的执行逻辑顺序是：`eslint`会首先读`extends`的规则，这个时候遇到了最后配置的`plugin:prettier/recommended`，而这个插件又会先读本地配置的`.prettierrc`文件再读取`prettier`自己内部设置的配置，最后读`.eslintrc.cjs`的`rules`配置。所以.`eslintrc.cjs`的`rules`优先级最高，可以覆盖`.prettierrc`的部分配置。\n\n优先级：本地`.eslintrc.cjs`的`rules` > 本地`.prettierrc`>`prettier`内部配置>`extends`其他配置>`eslintrc`内部默认配置。\n\n`prettier`配置完成后，再通过`eslint`插件对文件进行格式化，就能够正常格式化了。由此可知，对`eslint`进行扩展之后，`prettier`能够对js代码做的事，`eslint`也能，只要你制定好规则以及对应的处理。\n\n#### 2.3 安装Scripts命令\n\n执行下面命令，在`package.json`的scripts中生成命令，执行命令可以进行文件格式化\n\n```shell\npnpm pkg set scripts.format='prettier --write \"./**/*.{html,vue,ts,js,json,md,css}\"'\n```\n\n#### 2.4 配置文件保存自动格式\n\n同样的，我们不可能每写一行代码，就运行`pnpm format`来美化一次代码，我们希望保存代码时，就能够自动格式化代码。于是又需要安装prettier插件。然后再`ctrl+shift+p`打开`vscode`的`setting.json`文件，添加如下配置：\n```json\n //prettier可以格式化很多种格式，所以需要在这里对应配置下\n \"[html]\": {\n      \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[css]\": {\n      \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[less]\": {\n      \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[vue]\": {\n      \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[javascript]\": {\n      \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[typescriptreact]\": {\n      \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[jsonc]\": {\n      \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[typescript]\": {\n      \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[json]\": {\n      \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  //这个设置在ctrl+s的时候，会启用默认的格式化，这里是prettier\n  \"editor.formatOnSave\": true\n```\n或者在项目中的`.vscode`目录中的`settings.json`中进行如下配置：\n```json\n //prettier可以格式化很多种格式，所以需要在这里对应配置下\n \"[html]\": {\n      \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[css]\": {\n      \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[less]\": {\n      \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[vue]\": {\n      \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[javascript]\": {\n      \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[typescriptreact]\": {\n      \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[jsonc]\": {\n      \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[typescript]\": {\n      \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  \"[json]\": {\n      \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  },\n  //这个设置在ctrl+s的时候，会启用默认的格式化，这里是prettier\n  \"editor.formatOnSave\": true\n```\n#### 2.5 配置prettierignore\n`.perttierigonre`文件用于忽略那些文件不需要`Perttier`进行格式化，功能和`.gitignore`类似。项目根目录创建`.perttierignore`,配置如下：\n```js\ndist\nnode_modules\n**/*.svg\n**/*.sh\n```\n### 3 husky\n\n在`Git`中也存在一些钩子函数，通常成为`git hook`，其中较常用的有`pre-push`、`pre-commit`，其中`pre-commit`钩子会在`commit`前触发，`pre-push`会在`push`前触发。注意：所有钩子默认情况下是禁用的。\n\n为了保证不同的协作者，每次提交的`git`代码都是符合`Eslint`规范的，避免提交格式不统一或者错误的代码，为此我们可以使用`Eslint`配合`git hook`， 在进行`git commit`的时候验证`Eslint`规范。如果`Eslint`验证不通过，则不能提交。\n\n**husky**就是我们需要的`git hook`工具。使用`husky`，我们可以很方便配置`git hook`脚本，例如: `pre-commit`、 `pre-push`、 `commit-msg` 等.通过`git hook`触发`Eslint`规则校验，规范代码提交。\n\n下面是相关配置:\n\n#### 3.1 安装依赖\n\n```shell\npnpm install husky  -D\n```\n\n#### 3.2 husky配置\n<span id=\"commitlint\">1 在`package.json`中添加脚本命令,用于生成`.husky`目录</span>\n```shell\npnpm pkg set scripts.prepare=\"husky install\"\n```\n\n2 执行命令`pnpm  prepare`，在根目录创建`.husky`文件夹,将`git hooks`钩子交由`husky`执行,每次执行`pnpm install`会生成`.husky`脚本目录，如果目录存在，不会重复生成。\n\n```shell\npnpm  prepare\n```\n\n3 添加`commit-msg`钩子,在执行`git commit`命令时执行信息校验。\n\n```shell\nnpx husky add .husky/commit-msg 'npx --no-install commitlint --edit \"$1\"'\n```\n\n4 为了便于记住命令，可以将步骤3中的命令加入到`package.json`的`scripts`中\n\n```shell\n \"commit-msg\": \"npx husky add .husky/commit-msg \\\"npx --no-install commitlint --edit '$1'\\\"\"\n```\n\n### 4 lint-staged\n\n通过`git`提交代码时，通过`husky`触发`git hook`钩子进行`eslint`或者`prettier`校验时，往往都是全目录或者指定目录进行代码规范检测，这样就比较消耗时间，影响性能。我们都希望只对提交的代码进行规范检测，避免全目录检测，此时`lint-staged`刚好能满足我们的需求。\n\n`lint-staged`只扫描`git`暂存区的文件而不是全盘扫描，这样每次`lint`量就比较小，而且是符合我们的需求的。首先需要注意，`Lint-staged`仅仅是文件过滤器，不会帮你格式化任何东西，只需要在`package.json`中进行简单配置。\n\n#### 4.1 依赖安装\n\n```shell\npnpm install lint-staged -D\n```\n\n#### 4.2 lint-staged配置\n\n1 在`package.json`中进行如下配置:\n\n```json\n{\n    \"lint-staged\": {\n        \"*.{js,ts,tsx,jsx,json,md}\": [\"prettier --write\", \"eslint --fix\"],\n        \"*.vue\": [\"prettier --parser=vue --write\", \"eslint --fix\"],\n        \"*.css\": [\"prettier --write\"]\n    }\n}\n```\n\n2 设置`pre-commit`为运行`lint-staged`.在完成上面的配置之后，可以手动通过`npx lint-staged`, 来检查暂存区里面的文件。当然我们也可以通过`git hook`的钩子`pre-commit`来进行自动控制。执行下面命令在`husky`中进行设置：\n\n```shell\nnpx husky add .husky/pre-commit \"npx lint-staged\"\n```\n\n3 同时也可以将步骤2种的命令配置在`package.json`的`scripts`中：\n\n```shell\npnpm pkg set scripts.pre-commit=\"npx husky add .husky/pre-commit 'npx lint-staged'\"\n```\n\nlint-staged过滤文件采用glob模式,`git commit`时触发`pre-commit`钩子，运行`lint-staged`命令，执行`eslint`或者`prettier`命令。在`git commit`的时候就自动的回去帮我们跑检查脚本，而且还是只针对我们本次提交的代码进行检查。\n\n### 5 commitlint\n\n前面配置了通过`husky`执行了`pre-commit`钩子，在代码`git commit`前执行`npx lint-staged`，规范暂存区代码。下面就接着配置代码提交`commit-message`规范。多人协作开发，在提交代码时经常出现五花八门的`commit-message`,使得代码提交注释不统一，使得代码`reReview`很难。\n\n`commitlint`从名字就能看出是提交时`lint`,它针对`commit-message`进行`lint`.`commitlint`是一个提交代码时注释规范的工具。与`Eslint`类似，它定义了一套标准的代码提交注释信息规范。相关配置如下：\n\n#### 5.1 安装依赖\n\n```shell\npnpm install @commitlint/cli @commitlint/config-conventional -D\n```\n\n- @commitlint/cli: `commitlint`的命令行工具\n- @commitlint/config-conventional: `commitlint`校验的规则集，比较常用的`Conventional Commits`是`Angular`约定\n\n注意:` @commitlint/config-conventional`在后面会被移除\n\n#### 5.2 commitlint配置\n\n1 配置`commitlint`规则`commitlint.config.cjs`，注意文件名称后缀设置为`.cjs`\n\n```js\nmodule.exports = {\n    extends: ['@commitlint/config-conventional']\n}\n```\n\n2 此时文件`commitlint.config.cjs`会爆红，请在`tsconfig.json`增加如下设置\n\n```json\n{\n    \"include\": [\"commitlint.config.cjs\"]\n}\n```\n\n如果爆红未消失，重启`vscode`\n\n3 `commitlint.config.cjs`参数相关说明：生成的配置文件是默认的规则，也可以自己定义规则，提交格式则如下：\n\n```js\n<type>(<scope>): <subject>\n```\n\nI) **type**为必填项，用于指定`commit`的类型\n\n![](https://cdn.staticaly.com/gh/AnyFork/blog-images/main/markdown/202307202244657.jpg)\n\nII)**scope**为非必填项，用于描述改动的范围，可以是文件的名称，最好包含路径III)**subject**是必填项，这次提交的日志信息，提交日志必须有意义。\n\n一般情况下，`commitlint.config.cjs`中插件`@commitlint/config-conventional`默认的规则就够用了。当然，如果需要自定义限制这些规则，不启用默认的规则，可以把配置写的更详细\n\n```js\nmodule.exports = {\n    extends: ['@commitlint/config-conventional'],\n    rules: {\n        'type-enum': [2, 'always', ['upd', 'feat', 'fix', 'refactor', 'docs', 'chore', 'style', 'revert']],\n        'type-case': [0],\n        'type-empty': [0],\n        'scope-empty': [0],\n        'scope-case': [0],\n        'subject-full-stop': [0, 'never'],\n        'subject-case': [0, 'never'],\n        'header-max-length': [0, 'always', 72]\n    }\n}\n```\n\nrule配置说明: rule由name和配置数组组成，如：‘name:[0, ‘always’, 72]’，数组中第一位为level，可选0,1,2，0为disable，1为warning，2为error，第二位为应用与否，可选always|never，第三位该rule的值。\n\n4 配置`husky`,让`husky`触发`git hook`钩子`pre-commit`。相关设置已在步骤[3.2husky配置](#commitlint)中`第三步，第四步`配置过了，请跳转查看。\n\n### 6 commitizen\n\n上面通过`commitlint`规范了代码提交时`commit-message`的标准，但操作起来非常不顺手，交互感不够友好，很别扭。别着急，下面介绍的`commitizen`工具就能优化我们的交互体验。\n\n`Commitizen`是一个用于撰写Git提交信息的工具。它可以帮助开发人员遵循一个规范，以便更容易地阅读和维护Git仓库历史记录。`Commitizen`采用了一个交互式的命令行界面，引导你逐步填写必要的数据，从而生成符合规范的Git提交信息。相关配置如下：\n\n#### 6.1依赖安装\n\n```shell\npnpm install commitizen cz-conventional-changelog -D\n```\n\n#### 6.2 commitizen配置\n\n1 在`package.json` 中添加`commit`指令, 执行`git-cz`指令\n\n```shell\npnpm pkg set scripts.commit=\"git add . && git-cz\"\n```\n\n2 在项目目录里，运行下面的命令，使其支持`Vue`的`Commit message`格式，自动初始化命令行的选项信息\n\n```shell\ncommitizen init cz-conventional-changelog --save --save-exact\n```\n\n3 在`package.json`中添加配置：\n\n```json\n ...\n \"config\": {\n        \"commitizen\": {\n            \"path\": \"node_modules/cz-conventional-changelog\"\n        }\n  },\n  ...\n```\n\n以后，凡是用到`git commit`命令，一律改为使用`git cz`。这时，就会出现选项，用来生成符合格式的`Commit message`。通过执行命令`pnpm commit`测试如下： ![](https://cdn.staticaly.com/gh/AnyFork/blog-images/main/markdown/202307202317090.png)\n\n### 7 cz-customizable\n\n上面通过`commitizen`可以进行交互式操作，通过引导完成提交信息的填写，但是是英文的，也不够灵活。\n\n`cz-customizable`是一个`Commitizen`的插件，它允许你使用自定义的Git提交规范。通过为项目添加一个配置文件，你可以指定你自己的提交格式，并在使用`Commitizen`时使用该格式。你可以轻松地定义自己的提交类型、作用域和描述等信息.\n\n#### 7.1 依赖安装\n\n```shell\npnpm install  cz-customizable commitlint-config-cz --D\n```\n\n-   cz-customizable可自定义的`Commitizen`插件（或独立实用程序），可帮助实现一致的提交消息\n\n-   commitlint-config-cz用于配置`cz-customizable`提交模板和共享规则给`commitlint`校验\n\n#### 7.2 cz-customizable配置\n\n1 在`package.json`文件中，添加以下字段:\n\n```json\n\"config\": {\n  \"commitizen\": {\n    - \"path\": \"node_modules/cz-conventional-changelog\",\n    + \"path\": \"./node_modules/cz-customizable\"\n  }\n}\n```\n\n更改`commitizen`的path为`./node_modules/cz-customizable`，移除`node_modules/cz-conventional-changelog`,此时也可以移除`node_modules/cz-conventional-changelog`相关依赖。\n\n2 然后，在项目根目录下添加一个`.cz-config.cjs`文件，注意：文件后缀为：`cjs`,并定义你的提交类型、作用域和描述等信息。例如：\n\n```js\nmodule.exports = {\n    types: [\n        {\n            value: ':sparkles: feat',\n            name: '✨ feat:     新功能'\n        },\n        {\n            value: ':bug: fix',\n            name: '\uD83D\uDC1B fix:      修复bug'\n        },\n        {\n            value: ':package: build',\n            name: '\uD83D\uDCE6️ build:    打包'\n        },\n        {\n            value: ':zap: perf',\n            name: '⚡️ perf:     性能优化'\n        },\n        {\n            value: ':tada: release',\n            name: '\uD83C\uDF89 release:  发布正式版'\n        },\n        {\n            value: ':lipstick: style',\n            name: '\uD83D\uDC84 style:    代码的样式美化'\n        },\n        {\n            value: ':recycle: refactor',\n            name: '♻️  refactor: 重构'\n        },\n        {\n            value: ':pencil2: docs',\n            name: '✏️  docs:     文档变更'\n        },\n        {\n            value: ':white_check_mark: test',\n            name: '✅ test:     测试'\n        },\n        {\n            value: ':rewind: revert',\n            name: '⏪️ revert:   回退'\n        },\n        {\n            value: ':rocket: chore',\n            name: '\uD83D\uDE80 chore:    构建/工程依赖/工具'\n        },\n        {\n            value: ':construction_worker: ci',\n            name: '\uD83D\uDC77 ci:       CI related changes'\n        }\n    ],\n    scopes: [{ name: 'components' }, { name: 'assets' }, { name: 'router' }, { name: 'utils' }, { name: 'views' }, { name: 'types' }],\n    messages: {\n        type: '请选择提交类型(必填)',\n        customScope: '请输入文件修改范围(可选)',\n        subject: '请简要描述提交(必填)',\n        body: '请输入详细描述(可选)',\n        breaking: '列出任何BREAKING CHANGES(可选)',\n        footer: '请输入要关闭的issue(可选)',\n        confirmCommit: '确定提交此说明吗？'\n    },\n    allowCustomScopes: true,\n    subjectLimit: 100\n}\n```\n\n3 在`package.json`中增加如下配置：用于指定`cz-config.cjs`文件位置\n\n```json\n \"config\": {\n        \"cz-customizable\": {\n            \"config\": \".cz-config.cjs\"\n        }\n  },\n```\n\n`cz-customizable` 会首先在项目根目录下寻找: `.cz-config.js` 或 `.config/cz-config.js`，如果找不到，会去主目录寻找。我们也可以在`package.json`中手动去指定配置文件的路径\n\n#### 7.3 git-commit-emoji安装\n\n1 `git-commit-emoji`是一款支持在`commit-message`中输入`emoji`的插件，丰富提交信息\n\n```shell\npnpm install commitlint-config-git-commit-emoji -D\n```\n\n2 更新`commitlint.config.cjs`移除extends中原来的`@commitlint/config-conventional`，加入`'git-commit-emoji', 'cz'`\n\n```js\nmodule.exports = {\n    extends: ['git-commit-emoji', 'cz']\n}\n```\n\n最后，你可以使用以下命令来代替`git commit`:\n\n```shell\npnpm commit\n```\n\n这将启动`Commitizen`的交互式命令行界面，并引导你逐步填写必要的数据。此时你看到的便是定制话的`commit-message`交互式界面，还是带表情中文的。 ![](https://cdn.staticaly.com/gh/AnyFork/blog-images/main/markdown/202307202353662.png)\n\n### 8 conventional-changelog\n\n通过插`conventional-changelog`可以轻松的将`commit-message`转化为`changelog`\n\n#### 8.1 依赖安装\n\n```shell\npnpm install conventional-changelog conventional-changelog-cli -D\n```\n\n#### 8.2 conventional-changelog配置\n\n1 将`changelog`脚本添加到您的`package.json`\n\n```shell\npnpm pkg set scripts.changelog=\"conventional-changelog -p cz-config.cjs -i CHANGELOG.md -s -r 0\"\n```\n\n参数说明\n\n```js\n-p 指定风格*\n-i CHANGELOG.md 指定输出的文件名称\n-s 输出到infile，这样就不需要指定与outfile相同的文件\n-r 从最新的版本生成多少个版本。如果为0，则整个更改日志将被重新生成，输出文件将被覆盖。默认值:1\n-n ./changelog-option.js 指定自定义配置\n```\n\n2 运行命令生成最新`CHANGELOG`\n\n```shell\npnpm changelog\n```\n\n至此，更新日志生成完毕。\n\n### 9 VsCode插件\n\n上面都是通过命令行窗口进行代码提交信息交互，相对来说还不够智能。下面介绍一款`VScode`插件`git-commit-plugin`[点我下载安装](https://marketplace.visualstudio.com/items?itemName=redjue.git-commit-plugin)。该插件会在`VScode`的`git`插件的左上角生成一个小图标，点击按照交互式操作进行提交信息填写。\n\n## 五 项目下载\n\n1 `git clone` 项目源码到本地\n\n```shell\ngit clone https://github.com/AnyFork/vite-standard-template.git\n```\n\n2 安装项目依赖\n\n```shell\npnpm install\n```\n\n3 项目运行\n\n```shell\npnpm dev\n```\n\n## 六 参考文档\n\n<https://blog.csdn.net/Jackson_Wen/article/details/127921063> \n\n<https://zhuanlan.zhihu.com/p/270662897> \n\n<https://codeleading.com/article/66646301239/>",
			"articleWords": 12407,
			"articleReadTime": "41.36",
			"articleKeyWords": "Vite，Vue3，Alova，Unocss，Pinia，Naive UI，VueRouter",
			"articleDescription": "这是一个基于Vite4.X + Vue3.X + TypeScript + Naive UI + Pinia + VueRouter + Unocss + Alova + Eslint + Prettier + husky + lint-staged + commitlint + commitizen + cz-customizable+ conventional-changelog构建的标准的，简单通用的vue项目模板。",
			"articleAvatar": "https://cdn.staticaly.com/gh/AnyFork/blog-images/main/markdown/202307212141034.png",
			"articleReadCount": 6,
			"articleStatus": "0",
			"categoryInfo": {
				"createdTime": "2023-06-05 12:59:58",
				"createdBy": 1,
				"categoryId": "1665584221287206914",
				"categoryName": "Vue",
				"iconName": "vscode-icons:file-type-vue",
				"categoryStatus": "0",
				"categoryAlias": "vue",
				"orderNum": 44,
				"articleTotal": 0
			},
			"tagInfo": [{
				"createdTime": "2023-06-04 21:40:00",
				"updatedTime": "2023-06-04T21:55:59",
				"createdBy": 1,
				"updatedBy": 1,
				"tagId": "1665352703848005633",
				"tagName": "Vue3",
				"tagAlias": "vue3",
				"tagIcon": "vscode-icons:file-type-vue",
				"iconColor": "rgb(196, 22, 22)",
				"tagIconHref": "https://vuejs.org/",
				"tagGithubHref": "https://github.com/vuejs/core",
				"tagSummary": "The Progressive JavaScript Framework",
				"tagSort": 1,
				"tagStatus": "0",
				"articleTotal": 0
			}]
		},
		{
			"createdTime": "2023-07-07 11:35:46",
			"updatedTime": "2023-07-07T11:50:25",
			"createdBy": 1,
			"updatedBy": 1,
			"articleId": "1677159444338741250",
			"articleTitle": "Algolia开启网站全文搜索",
			"articleSummary": "Algolia 是一个数据库实时搜索服务，能够提供毫秒级的数据库搜索服务，并且其服务能以 API 的形式方便地布局到网页、客户端、APP 等多种场景。Algolia 的服务支持多种语言支持 Ruby、Rails、Python、PHP、JS、Java、Android、Objective-C 等多种语言，具备关键字输入智能容错功能，并提供有搜索排名配置，并具有实时快速的特点（Algolia 在全球 12 个数据中心均有部署）。Algolia 还为移动设备提供了离线搜索引擎，其 C++ SDK 可以嵌入到应用服务器端，这样即便没有网络连接应用也能提供搜索功能。",
			"articleCategory": "1677156930675576834",
			"articleContent": "!!! info Algolia 相关连接\n1、Algolia 管理后台地址：  \n<https://www.algolia.com/apps/09V7PWK61N/explorer/browse/anyfork?searchMode=search>  \n2、Algolia 爬虫后台地址：  \n<https://crawler.algolia.com/admin/crawlers/05c701e8-3f90-461a-8624-081309f68d92/overview>  \n3、Algolia GitHub地址:   \n<https://github.com/algolia/docsearch>\n4、Algolia DocSearch服务申请地址：\n<https://docsearch.algolia.com/apply/>\n!!!\n## 一、为什么在使用 Algolia?\n\n- 1、由于 VuePress 的内置搜索只会为页面的标题、h2 、 h3 以及 tags 构建搜索索引。如果你需要全文搜索，内置搜索无法实现，可则以使用 Algolia 搜索。\n- 2、使用 Algolia 搜索最大的好处就是方便，它会自动爬取网站的页面内容并构建索引，你只用申请一个 Algolia 服务，在网站上添加一些代码，就像添加统计代码一样，然后就可以实现一个全文搜索功能，操作简单还方便，容错率很高。\n- 3、使用范围广，目前很多应用的官方文档(例如：vue.js,vite,vuepress 等)均使用 Algolia 进行全文搜索，而且支持多种 Ruby、Rails、Python、PHP、JS、Java、Android、Objective-C 等多种语言，可以实现自动和手动爬取索引。展示效果如下:![](https://cdn.jsdelivr.net/gh/AnyFork/blog-images/markdown/202207210920996.png)\n\n## 如何使用 Algolia?\n\n- 1、**搜索服务申请**\n\n  - 1、申请地址：<https://docsearch.algolia.com/apply/>\n  - 2、填写应用 Algolia 搜索服务的站点地址，能够对外访问。\n  - 3、填写个人邮箱，申请通过后会收到回复邮件，包含开通的应用信息以及进行后续其他操作的说明。\n  - 4、填写公开的仓库地址，此仓库存放站点源码。\n\n  填完之后一周之内，收到回复邮件，按照邮件内容进行操作。记住一定要回复邮件，告诉自己就是网站的维护者，并且可以修改代码，否则超过时间不回复，申请的应用会被自动销毁。\n\n- 2、**代码配置**\n\n  - 1、如果你用的是 VuePress 的默认主题，VuePress 直接提供了 themeConfig.algolia 选项来用 Algolia 搜索替换内置的搜索框，你只用如此简单的配置即可实现全文搜索。\n\n  ```js\n  // .vuepress/config.js\n  module.exports = {\n    themeConfig: {\n      algolia: {\n        apiKey: '<API_KEY>',\n        indexName: '<INDEX_NAME>'\n        // 如果 Algolia 没有为你提供 `appId` ，使用 `BH4D9OD16A` 或者移除该配置项\n        appId: '<APP_ID>',\n      }\n    }\n  }\n\n  ```\n\n  - 2、如果你用的不是 VuePress 的默认主题，就比如我用的是`vuepress-theme-reco 1.x`，它的搜索栏是自己实现的，所以添加上述的配置是不会有效果的(1.6.10 版本中自定义的`AlgoliaSearchBox.vue`组件存在很多 bug)，这个时候就需要遵照邮件中的方法，手动添加 CSS 和 JavaScript 文件。<font color=\"red\">如果你直接引入 vuepress-theme-reco 1.x 包，</font>使用按照下面步骤进行配置：\n\n  1 我们需要先修改下 config.js:\n\n  ```js\n  module.exports = {\n    head: [\n      ['link', { href: 'https://cdn.jsdelivr.net/npm/@docsearch/css@3', rel: 'stylesheet' }],\n      ['script', { language: 'javascript', type: 'text/javascript', src: 'https://cdn.jsdelivr.net/npm/@docsearch/js@3' }]\n    ]\n  }\n  ```\n\n  2 然后修改.vuepress/enhanceApp.js 文件：\n\n  ```js\n  export default ({ router, Vue, isServer }) => {\n    Vue.mixin({\n      mounted() {\n        // 不加 setTimeout 会有报错，但不影响效果\n        setTimeout(() => {\n          try {\n            docsearch({\n              appId: '43GX903BPS',\n              apiKey: 'feff649032d8034cf2a636ef55d96054',\n              indexName: 'ts-yayujs',\n              container: '.search-box',\n              debug: false\n            })\n          } catch (e) {\n            console.log(e)\n          }\n        }, 100)\n      }\n    })\n  }\n  ```\n\n  <font color=\"red\">如果你是将 vuepress-theme-reco 1.x 主题进行本地化魔改</font>，主题中`Alglia`配置不变，可以对自定义组件`AlgoliaSearchBox.vue`修改如下：\n\n  ```vue\n  <template>\n    <div id=\"algolia-search-input\" class=\"search-box\"></div>\n  </template>\n  <script>\n  import { defineComponent, ref, onMounted } from 'vue'\n  import { RecoIcon } from '@vuepress-reco/core/lib/components'\n  import { useInstance } from '@theme/helpers/composable'\n  export default defineComponent({\n    props: ['options'],\n    setup(props, ctx) {\n      const initialize = (userOptions) => {\n        const { algoliaOptions = {} } = userOptions\n        docsearch(\n          Object.assign({}, userOptions, {\n            container: '#algolia-search-input',\n            algoliaOptions: algoliaOptions\n          })\n        )\n      }\n      onMounted(() => {\n        initialize(props.options)\n      })\n    }\n  })\n  </script>\n  <style>\n  .search-box .DocSearch.DocSearch-Button {\n    cursor: text;\n    height: 2rem;\n    color: #5b5b5b;\n    border: 1px solid var(--border-color);\n    border-radius: 2rem;\n    font-size: 0.9rem;\n    padding: 0 0.5rem 0 0rem;\n    outline: none;\n    transition: all 0.2s ease;\n    background: transparent;\n    background-size: 1rem;\n    margin: 0px;\n  }\n\n  .search-box .DocSearch-Button-Container {\n    margin-left: 0.4rem;\n  }\n\n  .search-box .DocSearch-Button .DocSearch-Search-Icon {\n    width: 15px;\n    height: 15px;\n    position: relative;\n    top: 0.1rem;\n  }\n\n  .search-box .DocSearch-Button-Placeholder {\n    font-size: 0.8rem;\n  }\n\n  .search-box .DocSearch-Button-Keys {\n    display: flex;\n    right: 0.1rem;\n  }\n\n  .search-box .DocSearch-Button-Key {\n    font-size: 12px;\n    line-height: 15px;\n    width:15px;\n    height:15px;\n  }\n  </style>\n  ```\n  注意其中的 container，参考 [docsearch](https://github.com/algolia/docsearch) 的官方仓库，这里提供的不是 input 输入框的选择器，而是一个挂载节点，比如 div 的选择器。如果样式自己不喜欢，可以通过修改`vuepress/styles/index.styl`覆盖目前的样式。最终效果如下：![](https://cdn.jsdelivr.net/gh/AnyFork/blog-images/markdown/202207211001028.png)\n\n## 数据爬取\n\n- 1、配置完毕后将网站进行重新部署，查看`Algolia`全局搜索是否有数据。\n- 2、如果你搜任何数据，都显示搜索不到数据，那很可能是爬取的数据有问题，我们登陆 https://www.algolia.com/ 打开管理后台，点击左侧选项栏里的 Search，查看对应的 indexName 数据，如果 Browse 这里没有显示数据，那说明爬取的数据可能有问题，导致没有生成对应的 Records：![](https://cdn.jsdelivr.net/gh/AnyFork/blog-images/markdown/202207211111162.png)\n如果没有数据，那我们就查下爬取的逻辑，打开爬虫后台：<https://crawler.algolia.com/admin/crawlers/05c701e8-3f90-461a-8624-081309f68d92/overview>，点击对应 indexName 进入后台：\n![](https://cdn.jsdelivr.net/gh/AnyFork/blog-images/markdown/202207211115127.png)如果显示成功爬取，也有 Monitoring Success 的数据，但 Records 为 0，那大概是爬虫提取数据的逻辑有问题，点击左侧选项栏中的 Editor，查看具体的爬虫逻辑：![](https://cdn.jsdelivr.net/gh/AnyFork/blog-images/markdown/202207211119981.png)像 pathsToMatch 这里如果是'https://anyfork.github.io/blog-docs/docs/**'，但你的网址都是 [https://anyfork.github.io/blog-docs/**](https://anyfork.github.io/blog-docs/**)开头的，那这里大概就是会提取错误，修改一下，然后点击右侧的数据进行测试：![](https://cdn.jsdelivr.net/gh/AnyFork/blog-images/markdown/202207211126112.png)如果能像这样提取到数据，就说明没有什么问题了，点击右上角的Save，然后切换回 Overview，点击右上角的 Restart crawling，我们重新爬取一下数据：![](https://cdn.jsdelivr.net/gh/AnyFork/blog-images/markdown/202207211128410.png)除了手动进行爬取之外，`Algolia`爬虫后台会定时爬取数据。至此， VuePress博客优化之开启Algolia全文搜索就配置完了，小伙伴赶紧开始吧！\n\n\n**参考文章**：<https://blog.csdn.net/weixin_55475226/article/details/123363042>",
			"articleWords": 1498,
			"articleReadTime": "4.99",
			"articleKeyWords": "Algolia,Algolia全文搜索,全文检索，网站全文检索",
			"articleDescription": "Algolia 是一个数据库实时搜索服务，能够提供毫秒级的数据库搜索服务，并且其服务能以 API 的形式方便地布局到网页、客户端、APP 等多种场景。Algolia 的服务支持多种语言支持 Ruby、Rails、Python、PHP、JS、Java、Android、Objective-C 等多种语言，具备关键字输入智能容错功能，并提供有搜索排名配置，并具有实时快速的特点（Algolia 在全球 12 个数据中心均有部署）。Algolia 还为移动设备提供了离线搜索引擎，其 C++ SDK 可以嵌入到应用服务器端，这样即便没有网络连接应用也能提供搜索功能。",
			"articleAvatar": "https://cdn.staticaly.com/gh/AnyFork/blog-images/main/markdown/202207210908451.jpg",
			"articleReadCount": 0,
			"articleStatus": "0",
			"categoryInfo": {
				"createdTime": "2023-07-07 11:25:47",
				"createdBy": 1,
				"categoryId": "1677156930675576834",
				"categoryName": "全文检索",
				"iconName": "ri:file-search-line",
				"categoryStatus": "0",
				"categoryAlias": "search",
				"orderNum": 45,
				"articleTotal": 0
			},
			"tagInfo": [{
				"createdTime": "2023-07-07 11:28:21",
				"createdBy": 1,
				"tagId": "1677157578360000513",
				"tagName": "Algolia",
				"tagAlias": "algolia",
				"tagIcon": "devicon:algolia",
				"tagIconHref": "https://github.com/algolia/docsearch",
				"tagGithubHref": "https://github.com/algolia/docsearch",
				"tagSummary": "Alogia DocSearch",
				"tagSort": 4,
				"tagStatus": "0",
				"articleTotal": 0
			}]
		},
		{
			"createdTime": "2022-12-22 17:00:53",
			"updatedTime": "2023-10-12T11:13:45",
			"createdBy": 1,
			"updatedBy": 1,
			"articleId": "1605850850092232706",
			"articleTitle": "使用explain分析sql语句执行效率",
			"articleSummary": "Explain命令在解决数据库性能上是第一推荐使用命令，大部分的性能问题可以通过此命令来简单的解决，Explain可以用来查看SQL语句的执行效果，可以帮助选择更好的索引和优化查询语句，写出更好的优化语句。",
			"articleCategory": "1712008554694610946",
			"articleContent": "## 1、什么是MySQL执行计划\n要对执行计划有个比较好的理解，需要先对MySQL的基础结构及查询基本原理有简单的了解。MySQL本身的功能架构分为三个部分，分别是 应用层、逻辑层、物理层，不只是MySQL ，其他大多数数据库产品都是按这种架构来进行划分的。\n- 应用层，主要负责与客户端进行交互，建立链接，记住链接状态，返回数据，响应请求，这一层是和客户端打交道的。\n- 逻辑层，主要负责查询处理、事务管理等其他数据库功能处理，以查询为例。\n- 物理层，实际物理磁盘上存储的文件，主要有分文数据文件，日志文件。\n\n        \n首先接收到查询SQL之后，数据库会立即分配一个线程对其进行处理，第一步查询处理器会对SQL查询进行优化，优化后会生成执行计划，然后交由计划执行器来执行。\n\n计划执行器需要访问更底层的事务管理器，存储管理器来操作数据，他们各自的分工各有不同，最终通过调用物理层的文件获取到查询结构信息，将最终结果响应给应用层。\n\n通过上面的描述，生成执行计划是执行一条SQL必不可少的步骤，一条SQL性能的好坏，可以通过查看执行计划很直观的看出来，执行计划提供了各种查询类型与级别，方面我们进行查看以及为作为性能分析的依据。\n## 2、如何分析执行计划\nMySQL为我们提供了`explain`关键字来直观的查看一条SQL的执行计划。`explain`显示了MySQL如何使用索引来处理select语句以及连接表，可以帮助选择更好的索引和写出更优化的查询语句。下面我们使用 `explain` 做一个查询，如下：\n```sql\nmysql> explain select * from payment;\n\n+----+-------------+---------+------------+------+---------------+------+---------+------+-------+----------+-------+\n\n| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra |\n\n+----+-------------+---------+------------+------+---------------+------+---------+------+-------+----------+-------+\n\n|  1 | SIMPLE      | payment | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 16086 |   100.00 | NULL  |\n\n+----+-------------+---------+------------+------+---------------+------+---------+------+-------+----------+-------+\n\n1 row in set, 1 warning (0.01 sec)\n```\n查询结构中有12列，理解每一列的含义，对理解执行计划至关重要，下面用一个表格的形式进行说明。\n| 列名称 | 属性说明 |\n| - | - |\n| id | SELECT识别符，这是SELECT的查询序列号。 |\n| select_type | `SIMPLE:`简单SELECT(不使用UNION或子查询)<br>`PRIMARY:`最外面的ELECT<br>`UNION:UNION`中的第二个或后面的SELECT语句<br>`DEPENDENT UNION:UNION`中的第二个或后面的SELECT语句,取决于外面的查询<br>`UNION RESULT:UNION` 的结果<br>`SUBQUERY:`子查询中的第一个SELECT<br>`DEPENDENT SUBQUERY:`子查询中的第一个SELECT,取决于外面的查询<br>`DERIVED:`导出表的SELECT(FROM子句的子查询)|\n| table | 输出的行所引用的表|\n| partitions| 如果查询是基于分区表的话，显示查询将访问的分区|\n|type|联接类型。下面给出各种联接类型,按照从最佳类型到最坏类型进行排序:<br> `system:`表仅有一行(=系统表)。这是const联接类型的一个特例。<br>`const:`表最多有一个匹配行,它将在查询开始时被读取。因为仅有一行,在这行的列值可被优化器剩余部分认为是常数。const表很快,因为它们只读取一次!<br>`eq_ref:`对于每个来自于前面的表的行组合,从该表中读取一行。这可能是最好的联接类型,除了const类型。<br>`ref:`对于每个来自于前面的表的行组合,所有有匹配索引值的行将从这张表中读取。<br>`ref_or_null:`该联接类型如同ref,但是添加了MySQL可以专门搜索包含NULL值的行。<br>`index_merge:`该联接类型表示使用了索引合并优化方法。<br>`unique_subquery:`该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高。<br>`index_subquery:`该联接类型类似于unique_subquery。可以替换IN子查询,但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr)<br>`range:`只检索给定范围的行,使用一个索引来选择行。<br>`index:`该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。<br>`ALL:`对于每个来自于先前的表的行组合,进行完整的表扫描，说明查询就需要优化了。<br>一般来说，得保证查询至少达到range级别，最好能达到ref。|\n| possible_keys | 指出MySQL能使用哪个索引在该表中找到行 |\n|key| 显示MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL。 |\n|key_len|显示MySQL决定使用的键长度。如果键是NULL,则长度为NULL。在不损失精确性的情况下，长度越短越好|\n|ref|显示使用哪个列或常数与key一起从表中选择行。|\n|rows| 显示MySQL认为它执行查询时必须检查的行数。多行之间的数据相乘可以估算要处理的行数。|\n|filtered|显示了通过条件过滤出的行数的百分比估计值。|\n|Extra|该列包含MySQL解决查询的详细信息<br>`Distinct:`MySQL发现第1个匹配行后,停止为当前的行组合搜索更多的行。<br>`Select tables optimized away MySQL`根本没有遍历表或索引就返回数据了，表示已经优化到不能再优化了<br>`Not exists:MySQL`能够对查询进行LEFT JOIN优化,发现1个匹配LEFT JOIN标准的行后,不再为前面的的行组合在该表内检查更多的行。<br>`range checked for each record (index map: #):MySQL`没有发现好的可以使用的索引,但发现如果来自前面的表的列值已知,可能部分索引可以使用。<br>`Using filesort:MySQL`需要额外的一次传递,以找出如何按排序顺序检索行，说明查询就需要优化了。<br>`Using index:`从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。<br>`Using temporary:`为了解决查询,MySQL需要创建一个临时表来容纳结果，说明查询就需要优化了。<br>`Using where:WHERE`子句用于限制哪一个行匹配下一个表或发送到客户。<br>`Using sort_union(...), Using union(...), Using intersect(...):`这些函数说明如何为index_merge联接类型合并索引扫描。<br>`Using index for group-by:`类似于访问表的Using index方式,Using index for group-by表示MySQL发现了一个索引,可以用来查 询GROUP BY或DISTINCT查询的所有列,而不要额外搜索硬盘访问实际的表.|",
			"articleWords": 1806,
			"articleReadTime": "6.02",
			"articleKeyWords": "mysql,sql语句执行效率",
			"articleDescription": "Explain命令在解决数据库性能上是第一推荐使用命令，大部分的性能问题可以通过此命令来简单的解决，Explain可以用来查看SQL语句的执行效果，可以帮助选择更好的索引和优化查询语句，写出更好的优化语句。",
			"articleAvatar": "https://cdn.staticaly.com/gh/AnyFork/blog-images/main/markdown/202203141729266.gif",
			"articleReadCount": 82,
			"articleStatus": "0",
			"categoryInfo": {
				"createdTime": "2023-10-11 15:33:42",
				"createdBy": 1,
				"categoryId": "1712008554694610946",
				"categoryName": "MySQL",
				"iconName": "logos:mysql",
				"categoryStatus": "0",
				"categoryAlias": "mysql",
				"orderNum": 46,
				"articleTotal": 0
			},
			"tagInfo": [{
				"createdTime": "2023-10-12 11:13:01",
				"createdBy": 1,
				"tagId": "1712305340843855873",
				"tagName": "SQL优化",
				"tagAlias": "SQL Optimization",
				"tagIcon": "logos:mysql",
				"tagSort": 6,
				"tagStatus": "0",
				"articleTotal": 0
			}]
		},
		{
			"createdTime": "2022-12-22 16:02:42",
			"updatedTime": "2023-10-12T11:14:09",
			"createdBy": 1,
			"updatedBy": 1,
			"articleId": "1605836209576325122",
			"articleTitle": "MySQL数据库SQL性能优化总结",
			"articleSummary": "本文主要记录日常工作中，MySQL数据库SQL性能优化。",
			"articleCategory": "1712008554694610946",
			"articleContent": "1.对查询进行优化，要尽量避免全表扫描，首先应考虑在`where`及`order by`涉及的列上建立索引。\n2.应尽量避免在`where`子句中对字段进行`null`值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：`select id from t where num is null`.\n3.应尽量避免在`where`子句中使用 `!=` 或 `<>`操作符，否则将引擎放弃使用索引而进行全表扫描。\n4.应尽量避免在`where`子句中使用`or`来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，如：\n```sql\nselect id from t where num=10 or Name = 'admin'\n可以这样查询：\nselect id from t where num = 10\nunion all\nselect id from t where Name = 'admin'\n```\n5.`in` 和`not in` 也要慎用，否则会导致全表扫描，如：\n```sql\nselect id from t where num in(1,2,3)\n对于连续的数值，能用 between 就不要用 in 了：\nselect id from t where num between 1 and 3\n很多时候用 exists 代替 in 是一个好的选择：\nselect num from a where num in(select num from b)\n用下面的语句替换：\nselect num from a where exists(select 1 from b where num=a.num)\n```\n6.下面的查询也将导致全表扫描：`select id from t where name like ‘%abc%’`若要提高效率，可以考虑全文检索\n7.如果在`where`子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：\n```sql\nselect id from t where num = @num\n# 可以改为强制查询使用索引：\n`select id from t with(index(索引名)) where num = @num`\n```\n\n8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：\n```sql\nselect id from t where num/2 = 100\n应改为:\nselect id from t where num = 100*2\n```\n9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：\n```sql\nselect id from t where substring(name,1,3) = 'abc'     -–name以abc开头的id\nselect id from t where datediff(day,createdate,’2005-11-30′) = 0    -–‘2005-11-30’    --生成的id\n应改为:\nselect id from t where name like 'abc%'\nselect id from t where createdate >= '2005-11-30' and createdate < '2005-12-1'\n```\n10.不要在`where`子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。\n11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。\n12.不要写一些没有意义的查询，如需要生成一个空表结构：\n```sql\nselect col1,col2 into #t from t where 1=0\n这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：\ncreate table #t(…)\n```\n13.`Update` 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。\n\n14.对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差。\n\n15.`select count(*) from table；`这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，是一定要杜绝的。\n\n16.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。\n\n17.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。\n\n18.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连 接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。\n\n19.尽可能的使用`varchar/nvarchar 代替 char/nchar` ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。\n\n20.任何地方都不要使用`select * from t` ，用具体的字段列表代替“*”，不要返回用不到的任何字段。\n\n21.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。\n\n22. 避免频繁创建和删除临时表，以减少系统表资源的消耗。临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。\n\n23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。\n\n24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。\n\n25.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。\n\n26.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。\n\n27.与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。\n\n28.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。\n\n29.尽量避免大事务操作，提高系统并发能力。\n\n30.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。\n\n\n",
			"articleWords": 1962,
			"articleReadTime": "6.54",
			"articleKeyWords": "MySQL,MySQL数据库,SQL性能优化",
			"articleDescription": "MySQL数据库SQL性能优化",
			"articleAvatar": "https://cdn.staticaly.com/gh/AnyFork/blog-images/main/markdown/202203141729266.gif",
			"articleReadCount": 7,
			"articleStatus": "0",
			"categoryInfo": {
				"createdTime": "2023-10-11 15:33:42",
				"createdBy": 1,
				"categoryId": "1712008554694610946",
				"categoryName": "MySQL",
				"iconName": "logos:mysql",
				"categoryStatus": "0",
				"categoryAlias": "mysql",
				"orderNum": 46,
				"articleTotal": 0
			},
			"tagInfo": [{
				"createdTime": "2023-10-12 11:13:01",
				"createdBy": 1,
				"tagId": "1712305340843855873",
				"tagName": "SQL优化",
				"tagAlias": "SQL Optimization",
				"tagIcon": "logos:mysql",
				"tagSort": 6,
				"tagStatus": "0",
				"articleTotal": 0
			}]
		},
		{
			"createdTime": "2022-12-21 14:42:14",
			"updatedTime": "2022-12-21T15:31:42",
			"createdBy": 1,
			"updatedBy": 1,
			"articleId": "1605453571032096769",
			"articleTitle": "Nginx日志配置详解",
			"articleSummary": "Nginx 日志对于统计、系统服务排错很有用。Nginx 日志主要分为两种：access_log(访问日志)和 error_log(错误日志)。通过访问日志我们可以得到用户的 IP 地址、浏览器的信息，请求的处理时间等信息。错误日志记录了访问出错的信息，可以帮助我们定位错误的原因。本文将详细描述一下如何配置 Nginx 日志。",
			"articleCategory": "1665302031547015169",
			"articleContent": "## 设置 access_log\n\n&emsp;访问日志主要记录客户端的请求。客户端向 Nginx 服务器发起的每一次请求都记录在这里。客户端 IP，浏览器信息，referer，请求处理时间，请求 URL 等都可以在访问日志中得到。当然具体要记录哪些信息，你可以通过 log_format 指令定义。\n\n语法如下：\n\n```bash\n# 设置访问日志\naccess_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]];\n# 关闭访问日志\naccess_log off;\n```\n\n- path 指定日志的存放位置。\n- format 指定日志的格式。默认使用预定义的 combined。\n- buffer 用来指定日志写入时的缓存大小。默认是 64k。\n- gzip 日志写入前先进行压缩。压缩率可以指定，从 1 到 9 数值越大压缩比越高，同时压缩的速度也越慢。默认是 1。\n- flush 设置缓存的有效时间。如果超过 flush 指定的时间，缓存中的内容将被清空。\n- if 条件判断。如果指定的条件计算为 0 或空字符串，那么该请求不会写入日志。\n\n另外，还有一个特殊的值 off。如果指定了该值，当前作用域下的所有的请求日志都被关闭。  \n作用域：可以应用 access_log 指令的作用域分别有 http，server，location，limit_except。也就是说，在这几个作用域外使用该指令，Nginx 会报错。  \n基本用法：\n\n```bash\n#该例子指定日志的写入路径为/var/logs/nginx-access.log，日志格式使用默认的combined。\naccess_log /var/logs/nginx-access.log\n#或\n#该例子指定日志的写入路径为/var/logs/nginx-access.log，日志格式使用默认的combined，指定日志的缓存大小为32k，日志写入前启用gzip进行压缩，压缩比使用默认值1，缓存数据有效时间为1分钟。\naccess_log /var/logs/nginx-access.log buffer=32k gzip flush=1m\n```\n\n### 使用 log_format 自定义日志格式\n\nNginx 预定义了名为 combined 日志格式，如果没有明确指定日志格式默认使用该格式：\n\n```bash\nlog_format combined '$remote_addr - $remote_user [$time_local] ''\"$request\" $status $body_bytes_sent ''\"$http_referer\" \"$http_user_agent\"';\n```\n\n如果不想使用 Nginx 预定义的格式，可以通过 log_format 指令来自定义：`log_format name [escape=default|json] string ...; `\n\n- name 格式名称。在 access_log 指令中引用。\n- escape 设置变量中的字符编码方式是 json 还是 default，默认是 default。\n- string 要定义的日志格式内容。该参数可以有多个。参数中可以使用 Nginx 变量。\n\n下面演示一下自定义日志格式的使用:\n\n```bash\naccess_log /var/logs/nginx-access.log main\nlog_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                  '$status $body_bytes_sent \"$http_referer\" '\n                  '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n```\n\n## 设置 error_log\n\n错误日志在 Nginx 中是通过 error_log 指令实现的。该指令记录服务器和请求处理过程中的错误信息。配置错误日志文件的路径和日志级别：\n\n```bash\nerror_log file [level];\nDefault:\nerror_log logs/error.log error;\n```\n\n第一个参数指定日志的写入位置。\n\n第二个参数指定日志的级别。level 可以是 debug, info, notice, warn, error, crit, alert,emerg 中的任意值。可以看到其取值范围是按紧急程度从低到高排列的。只有日志的错误级别等于或高于 level 指定的值才会写入错误日志中。默认值是 error。\n\n基本用法：`error_log /var/logs/nginx/nginx-error.log`。它可以配置在：main， http, mail, stream, server, location 作用域。例子中指定了错误日志的路径为：/var/logs/nginx/nginx-error.log，日志级别使用默认的 error\n\n## open_log_file_cache\n\n每一条日志记录的写入都是先打开文件再写入记录，然后关闭日志文件。如果你的日志文件路径中使用了变量，如 access_log /var/logs/$host/nginx-access.log，为提高性能，可以使用 open_log_file_cache 指令设置日志文件描述符的缓存。\n语法：`open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time];`\n\n- max 设置缓存中最多容纳的文件描述符数量，如果被占满，采用 LRU 算法将描述符关闭。\n- inactive 设置缓存存活时间，默认是 10s。\n- min_uses 在 inactive 时间段内，日志文件最少使用几次，该日志文件描述符记入缓存，默认是 1 次。\n- valid：设置多久对日志文件名进行检查，看是否发生变化，默认是 60s。\n- off：不使用缓存。默认为 off。\n\n基本用法：`open_log_file_cache max=1000 inactive=20s valid=1m min_uses=2;`。它可以配置在 http、server、location 作用域中。例子中，设置缓存最多缓存 1000 个日志文件描述符，20s 内如果缓存中的日志文件描述符至少被被访问 2 次，才不会被缓存关闭。每隔 1 分钟检查缓存中的文件描述符的文件名是否还存在。\n",
			"articleWords": 1176,
			"articleReadTime": "3.92",
			"articleKeyWords": "nginx,nginx日志",
			"articleDescription": "Nginx 日志对于统计、系统服务排错很有用。Nginx 日志主要分为两种：access_log(访问日志)和 error_log(错误日志)。通过访问日志我们可以得到用户的 IP 地址、浏览器的信息，请求的处理时间等信息。错误日志记录了访问出错的信息，可以帮助我们定位错误的原因。本文将详细描述一下如何配置 Nginx 日志。",
			"articleAvatar": "https://cdn.staticaly.com/gh/AnyFork/blog-images/main/markdown/202207201036989.jpg",
			"articleReadCount": 2,
			"articleStatus": "0",
			"categoryInfo": {
				"createdTime": "2023-06-04 18:18:39",
				"createdBy": 1,
				"categoryId": "1665302031547015169",
				"categoryName": "Java",
				"iconName": "devicon:java-wordmark",
				"categoryStatus": "0",
				"categoryAlias": "java",
				"orderNum": 42,
				"articleTotal": 0
			},
			"tagInfo": []
		},
		{
			"createdTime": "2022-12-21 14:40:39",
			"createdBy": 1,
			"articleId": "1605453171029712897",
			"articleTitle": "Nginx location匹配规则",
			"articleSummary": "nginx 的 location 指令的作用是根据用户请求的 URI 来执行不同的应用，URI 就是根据用户请求到的网址 URL 进行匹配，匹配成功了进行相关的操作。一个 location 可以用 prefix string(前缀字符串)定义，也可以通过 regular expression（正则表达式来定义）。通俗的说也就是：我们可以通过使用不同的前缀，表达不同的含义，对于不同的前缀可以分为两大类：普通 location 和正则 location",
			"articleCategory": "1665302031547015169",
			"articleContent": "## location\n\n&emsp;对于不同的前缀可以分为两大类：普通 location 和正则 location。符号：”~”表示 uri 包含正则，并且区分大小写。符号：“~\\*”表示 uri 包含正则，但不区分大小写。Nginx 服务器会首先会检查多个 location 中是否有普通的 uri 匹配，如果有多个匹配，会先记住匹配度最高的那个。然后再检查正则匹配，这里切记正则匹配是有顺序的，从上到下依次匹配，一旦匹配成功，则结束检查，并就会使用这个 location 块处理此请求。如果正则匹配全部失败，就会使用刚才记录普通 uri 匹配度最高的那个 location 块处理此请求。当普通匹配的最长前缀匹配有符号“^~”的时候，就不会在匹配正则。直接使用当前匹配的这个 location 块处理此请求。使用符号“=”修饰符可以定义一个精确匹配的 URI 和位置，如果找到了一个精确的匹配，则搜索终止，例如，如果一个”/”请求频繁发生，定义“location =/”将加快这些请求的处理，一旦精确匹配只有就结束，这样的 location 显然不能包含嵌套 location。\n\n这里我们说一下 location / {} 和 location =/ {}的区别：\n\n“location / {}”是普通的最大前缀匹配，任何的 uri 肯定是以“/”开头，所以 location / {} 可以说是默认匹配，当其他都不匹配了，则匹配默认匹配。  \n根据上述官网内容进行总结\na. ”=”用于普通 uri 前，要求精确匹配，如果匹配成功，则停止搜索并用当前 location 处理此请求\n\nb. ”~” 表示 uri 包含正则，并且区分大小写\n\nc. “~\\*”表示 uri 包含正则，但不区分大小写\n\nd. ”^~”表示在普通 uri 前要求 Nginx 服务器找到普通 uri 匹配度最高的那个 location 后，立即处理此请求，并不再进行正则匹配。\n\ne. ”^~”和“=”都可以阻止继续匹配正则 location 两者的区别：“^~”依然遵守最大前缀原则，然后“=”是需要严格匹配。\n\n注意：如果是普通 uri 匹配，这个时候是没有顺序的，但是正则匹配则是有顺序的，是从上到下依次匹配，一旦有匹配成功，则停止后面的匹配。\n\n## location 匹配规则顺序图\n\n![](https://cdn.jsdelivr.net/gh/AnyFork/blog-images/markdown/202203141144181.png)\n\n文章参考来源：<https://www.cnblogs.com/zhaof/p/5945576.html>",
			"articleWords": 622,
			"articleReadTime": "2.07",
			"articleKeyWords": "nginx,nginx location匹配规则",
			"articleDescription": "nginx 的 location 指令的作用是根据用户请求的 URI 来执行不同的应用，URI 就是根据用户请求到的网址 URL 进行匹配，匹配成功了进行相关的操作。一个 location 可以用 prefix string(前缀字符串)定义，也可以通过 regular expression（正则表达式来定义）。通俗的说也就是：我们可以通过使用不同的前缀，表达不同的含义，对于不同的前缀可以分为两大类：普通 location 和正则 location",
			"articleAvatar": "https://cdn.staticaly.com/gh/AnyFork/blog-images/main/markdown/202207201031629.jpg",
			"articleReadCount": 2,
			"articleStatus": "0",
			"categoryInfo": {
				"createdTime": "2023-06-04 18:18:39",
				"createdBy": 1,
				"categoryId": "1665302031547015169",
				"categoryName": "Java",
				"iconName": "devicon:java-wordmark",
				"categoryStatus": "0",
				"categoryAlias": "java",
				"orderNum": 42,
				"articleTotal": 0
			},
			"tagInfo": []
		},
		{
			"createdTime": "2022-12-21 14:38:11",
			"createdBy": 1,
			"articleId": "1605452551531012098",
			"articleTitle": "Nginx Gzip资源压缩",
			"articleSummary": "Nginx Gzip 压缩功能， 可以使网站的 css、js 、xml、html 等静态资源在传输时进行压缩，经过 Gzip 压缩后资源可以变为原来的 30%甚至更小，尽管这样会消耗一定的 cpu 资源，但是会节约大量的出口带宽来提高访问速度",
			"articleCategory": "1665302031547015169",
			"articleContent": "## Gzip 压缩\n\n&emsp;Nginx 开启 Gzip 压缩功能，可以使网站的 css、js 、xml、html 文件在传输时进行压缩，提高网页的访问速度,有效地节约带宽,进而优化 Nginx 性能! 经过 Gzip 压缩后页面大小可以变为原来的 30%甚至更小，这样，用户浏览页面的时候速度会快得多。Gzip 的压缩页面需要浏览器和服务器双方都支持，实际上就是服务器端压缩，传到浏览器后浏览器解压并解析。浏览器那里不需要我们担心，因为目前的巨大多数浏览器 都支持解析 Gzip 过的页面。  \n&emsp;开启 Gzip 功能后，Nginx 服务器会根据配置的策略对发送的内容, 如 css、js、xml、html 等静态资源进行压缩, 使得这些内容大小减少，在用户接收到返回内容之前对其进行处理，以压缩后的数据展现给客户。这样不仅可以节约大量的出口带宽，提高传输效率，还能提升用户快的感知体验, 一举两得; 尽管会消耗一定的 cpu 资源，但是为了给用户更好的体验还是值得的。  \n&emsp;Web 网站上的图片，视频等其它多媒体文件以及大文件，因为压缩前后文件大小压缩差异不大，压缩效果不好，反而会增加 cup 的消耗，所以对于图片或大文件没有必要进行压缩。如果想要优化，可以采用客户端缓存的方法进行性能优化。Gzip 压缩可以配置 http,server 和 location 模块下。  \n&emsp;对于字体的处理,只需要为 ttf、otf 和 svg 字体启用 gzip，对其他字体格式进行 gzip 压缩时效果不明显。`gzip_types font/ttf font/otf image/svg+xml `\n\n## Nginx 开启 Gzip 压缩参数说明\n\n```bash\n# 开启gzip压缩服务\ngzip on;\n\n# gzip压缩是要申请临时内存空间的，假设前提是压缩后大小是小于等于压缩前的。\n# 例如，如果原始文件大小为10K，那么它超过了8K，所以分配的内存是8 * 2 = 16K;再例如，\n# 原始文件大小为18K，很明显16K也是不够的，那么按照 8 * 2 * 2 = 32K的大小申请内存。\n# 如果没有设置，默认值是申请跟原始数据相同大小的内存空间去存储gzip压缩结果。\n\n# 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。\n# 例如 4 4k 代表以4k为单位，按照原始数据大小以4k为单位的4倍申请内存。\n# 4 8k 代表以8k为单位，按照原始数据大小以8k为单位的4倍申请内存。\n# 如果没有设置，默认值是申请跟原始数据相同大小的内存空间去存储gzip压缩结果。\ngzip_buffers 2 8k;\n\n# nginx对于静态文件的处理模块。\n# 该模块可以读取预先压缩的gz文件，这样可以减少每次请求进行gzip压缩的CPU资源消耗。\n# 该模块启用后，nginx首先检查是否存在请求静态文件的gz结尾的文件，如果有则直接返回该gz文件内容。\n# 为了要兼容不支持gzip的浏览器，启用gzip_static模块就必须同时保留原始静态文件和gz文件。\n# 这样的话，在有大量静态文件的情况下，将会大大增加磁盘空间。我们可以利用nginx的反向代理功能实现只保留gz文件。\ngzip_static on|off\n\n# 启用gzip压缩的最小文件，小于设置值的文件将不会压缩\ngzip_min_length 1k;\n\n# gzip压缩基于的http协议版本，默认就是HTTP 1.1\ngzip_http_version 1.1;\n\n# gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明\ngzip_comp_level 2;\n\n# 需要进行gzip压缩的Content-Type的Header的类型。建议js、text、css、xml、json都要进行压缩；\n# 图片就没必要了，gif、jpge文件已经压缩得很好了，就算再压，效果也不好，而且还耗费cpu。\n# javascript有多种形式。其中的值可以在 mime.types 文件中找到。\ngzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\n\n# 默认值：off\n# Nginx作为反向代理的时候启用，开启或者关闭后端服务器返回的结果，匹配的前提是后端服务器必须要返回包含\"Via\"的 header头。\n# off - 关闭所有的代理结果数据的压缩\n# expired - 启用压缩，如果header头中包含 \"Expires\" 头信息\n# no-cache - 启用压缩，如果header头中包含 \"Cache-Control:no-cache\" 头信息\n# no-store - 启用压缩，如果header头中包含 \"Cache-Control:no-store\" 头信息\n# private - 启用压缩，如果header头中包含 \"Cache-Control:private\" 头信息\n# no_last_modified - 启用压缩,如果header头中不包含 \"Last-Modified\" 头信息\n# no_etag - 启用压缩 ,如果header头中不包含 \"ETag\" 头信息\n# auth - 启用压缩 , 如果header头中包含 \"Authorization\" 头信息\n# any - 无条件启用压缩\ngzip_proxied [off|expired|no-cache|no-store|private|no_last_modified|no_etag|auth|any] ...\n\n# 是否在http header中添加Vary: Accept-Encoding，建议开启\n# 和http头有关系，加个vary头，给代理服务器用的，有的浏览器支持压缩，\n# 有的不支持，所以避免浪费不支持的也压缩，所以根据客户端的HTTP头来判断，是否需要压缩\ngzip_vary on;\n\n# 禁用IE 6 gzip\ngzip_disable \"MSIE [1-6]\\.\";\n```\n\n## 客户端和服务器进行 gzip 压缩的请求和处理过程\n\n![](https://cdn.jsdelivr.net/gh/AnyFork/blog-images/main/markdown/202203141006242.png)\n\n- 整个请求过程来看，开启 gzip 和不开启 gip 功能，其 http 的请求和返回过程是一致的，不同的是参数。\n- 当开启 HTTP 的 gzip 功能时，客户端发出 http 请求时，会通过 headers 中的 Accept-Encoding 属性告诉服务器“我支持 gzip 解压，解压格式（算法）deflate,sdch 为：”。Accept-Encoding:gzip,deflate,sdch。\n  注意，不是 request 说自己支持解压，Nginx 返回 response 数据的时候就一定会压缩。这还要看本次 Nginx 返回数据的格式是什么，如果返回数据的原始数据格式，和设置的 gzip_types 相符合，这时 Nginx 才会进行压缩。\n- Nginx 返回 response headers 是，如果数据被压缩了，就会在 Content-Encoding 属性中标示 gzip，表示接下来返回的 response\n- content 是经过压缩的；并且在 Content-Type 属性中表示数据的原始格式。最后返回经过压缩的 response content 给客户端，客户端再进行解压。这里注意一下，在客户端发送的 headers 里面，有一个 deflate,sdch。这是两种压缩算法，如果读者感兴趣，可以查查相关的资料（我建议查查，了解哈弗曼压缩算法对扩展自己的架构思路很有帮助）\n",
			"articleWords": 1765,
			"articleReadTime": "5.88",
			"articleKeyWords": "nginx,nginx压缩",
			"articleDescription": "Nginx Gzip 压缩功能， 可以使网站的 css、js 、xml、html 等静态资源在传输时进行压缩，经过 Gzip 压缩后资源可以变为原来的 30%甚至更小，尽管这样会消耗一定的 cpu 资源，但是会节约大量的出口带宽来提高访问速度",
			"articleAvatar": "https://cdn.staticaly.com/gh/AnyFork/blog-images/main/markdown/202207201100605.jpg",
			"articleReadCount": 2,
			"articleStatus": "0",
			"categoryInfo": {
				"createdTime": "2023-06-04 18:18:39",
				"createdBy": 1,
				"categoryId": "1665302031547015169",
				"categoryName": "Java",
				"iconName": "devicon:java-wordmark",
				"categoryStatus": "0",
				"categoryAlias": "java",
				"orderNum": 42,
				"articleTotal": 0
			},
			"tagInfo": []
		},
		{
			"createdTime": "2022-12-21 14:36:43",
			"createdBy": 1,
			"articleId": "1605452181366906882",
			"articleTitle": "Nginx Cache缓存配置",
			"articleSummary": "Nginx作为Web缓存服务器，它介于客户端和应用服务器之间，当用户通过浏览器访问一个URL时，web缓存服务器会去应用服务器获取要展示给用户的内容，将内容缓存到自己的服务器上，当下一次请求到来时，如果访问的是同一个URL，web缓存服务器就会直接将之前缓存的内容返回给客户端，而不是向应用服务器再次发送请求。web缓存降低了应用服务器、数据库的负载，减少了网络延迟，提高了用户访问的响应速度，增强了用户的体验。",
			"articleCategory": "1665302031547015169",
			"articleContent": "## 浏览器缓存的作用是什么？\n\n&emsp;1. 缓存可以减少冗余的数据传输。节省了网络带宽，从而更快的加载页面。  \n&emsp;2. 缓存降低了服务器的要求，从而服务器更快的响应。\n\n## 缓存的资源文件到什么地方去了呢？\n\n&emsp;根据缓存的资源存储的位置缓存分为`内存缓存(memory cache)`和`磁盘缓存(disk cache)` memory cache: 它是将资源文件缓存到内存中，等下次请求访问的时候不需要重新下载资源，而是直接从内存中读取数据。disk cache: 它是将资源文件缓存到硬盘中，等下次请求的时候它是直接从硬盘中读取。二者区别如下：\n\n- memory cache(内存缓存)退出进程时数据会被清除，而 disk cache(硬盘缓存)退出进程时数据不会被清除。内存读取比硬盘中读取的速度更快。但是我们也不能把所有数据放在内存中缓存的，因为内存也是有限的。\n- memory cache(内存缓存)一般会将脚本、字体、图片会存储到内存缓存中。\n- disk cache(硬盘缓存) 一般非脚本会存放在硬盘中，比如 css 这些。\n\n&emsp;缓存读取的原理：先从内存中查找对应的缓存，如果内存中能找到就读取对应的缓存，否则的话就从硬盘中查找对应的缓存，如果有就读取，否则的话，就重新网络请求。\n&emsp;浏览器缓存分为：`强制缓存和协商缓存`  \n&emsp;协商缓存原理：客户端向服务器端发出请求，服务端会检测是否有对应的标识，如果没有对应的标识，服务器端会返回一个对应的标识给客户端，客户端下次再次请求的时候，把该标识带过去，然后服务器端会验证该标识，如果验证通过了，则会响应 304，告诉浏览器读取缓存。如果标识没有通过，则返回请求的资源。那么协商缓存的标识又有 2 种：`ETag/if-None-Match` 和 `Last-Modified/if-Modify-Since`\n\n## 协商缓存 Last-Modified/if-Modify-Since\n\n&emsp;浏览器第一次发出请求一个资源的时候，服务器会返回一个 last-Modify 到 hearer 中. Last-Modify 含义是最后的修改时间。当浏览器再次请求的时候，request 的请求头会加上 if-Modify-Since，该值为缓存之前返回的 Last-Modify. 服务器收到 if-Modify-Since 后，根据资源的最后修改时间(last-Modify)和该值(if-Modify-Since)进行比较，如果相等的话，则命中缓存，返回 304，否则, 如果 Last-Modify > if-Modify-Since, 则会给出 200 响应，并且更新 Last-Modify 为新的值\n\n## 协商缓存 ETag/if-None-Match\n\n&emsp;ETag 的原理和上面的 last-modified 是类似的。ETag 则是对当前请求的资源做一个唯一的标识。该标识可以是一个字符串，文件的 size,hash 等。只要能够合理标识资源的唯一性并能验证是否修改过就可以了。ETag 在服务器响应请求的时候，返回当前资源的唯一标识(它是由服务器生成的)。但是只要资源有变化，ETag 会重新生成的。浏览器再下一次加载的时候会向服务器发送请求，会将上一次返回的 ETag 值放到 request header 里的 if-None-Match 里面去，服务器端只要比较客户端传来的 if-None-Match 值是否和自己服务器上的 ETag 是否一致，如果一致说明资源未修改过，因此返回 304，如果不一致，说明修改过，因此返回 200。并且把新的 Etag 赋值给 if-None-Match 来更新该值\n\n## last-modified 和 ETag 之间对比\n\n- 1. 在精度上，ETag 要优先于 last-modified。\n- 2. 在性能上，Etag 要逊于 Last-Modified，Last-Modified 需要记录时间，而 Etag 需要服务器通过算法来计算出一个 hash 值。\n- 3. 在优先级上，服务器校验优先考虑 Etag。\n\n## 理解强制缓存\n\n&emsp;基本原理：浏览器在加载资源的时候，会先根据本地缓存资源的 header 中的信息(Expires 和 Cache-Control)来判断是否需要强制缓存。如果命中的话，则会直接使用缓存中的资源。否则的话，会继续向服务器发送请求。  \n&emsp;Expires 是 http1.0 的规范，它的值是一个绝对时间的 GMT 格式的时间字符串。这个时间代表的该资源的失效时间，如果在该时间之前请求的话，则都是从缓存里面读取的。但是使用该规范时，可能会有一个缺点就是当服务器的时间和客户端的时间不一样的情况下，会导致缓存失效。  \n&emsp;Cache-Control 是 http1.1 的规范，它是利用该字段 max-age 值进行判断的。该值是一个相对时间，比如 Cache-Control: max-age=3600, 代表该资源的有效期是 3600 秒。除了该字段外，我们还有如下字段可以设置：\n\n- no-cache: 需要进行协商缓存，发送请求到服务器确认是否使用缓存。\n\n- no-store：禁止使用缓存，每一次都要重新请求数据。\n\n- public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。\n\n- private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。\n\n&emsp;**注意：Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候 Cache-Control 优先级高**\n\n## nginx 缓存配置\n\n&emsp;可以在一定程度上，减少服务器的处理请求压力。比如对一些图片，大文件，css 或 js 做一些缓存，那么在每次刷新浏览器的时候，就不会重新请求了，而是从缓存里面读取。这样就可以减轻服务器的压力。nginx 可配置的缓存又有 2 种：\n\n- 1 客户端的缓存(一般指浏览器的缓存)。\n- 2 服务端的缓存(使用 proxy-cache 实现的)。  \n  **注意：客户端的缓存一般有如下两种方式实现：协商缓存和强缓存。**\n\n```bash\nserver {\n  location ~* \\.(html)$ {\n    access_log off;\n    add_header  Cache-Control  max-age=no-cache;\n  }\n\n  location ~* \\.(css|js|png|jpg|jpeg|gif|gz|svg|mp4|ogg|ogv|webm|htc|xml|woff)$ {\n    # 同上，通配所有以.css/.js/...结尾的请求\n    access_log off;\n    add_header    Cache-Control  max-age=360000;\n  }\n}\n```\n\n~_ 的含义是：通配任意字符（且大小写不敏感），\\转义字符，因此 ~_ \\.(html)$的含义是：匹配所有以.html 结尾的请求\naccess_log off; 的含义是 关闭日志功能。  \n**add_header Cache-Control max-age=no-cache;** 的含义：html 文件不设置强制缓存时间，协商缓存，使用 Last-Modified。no-cache 会发起往返通信来验证缓存的响应，但如果资源未发生变化，则不会下载，返回 304  \n**add_header Cache-Control max-age=360000;** 的含义给上面匹配后缀的文件设置强制缓存，且缓存的时间是 360000 秒，第一次访问的时候，从服务器请求，当除了第一次以外，再次刷新浏览器，会从浏览器缓存读取，那么强制缓存一般是从内存里面先读取，如果内存没有，再从硬盘读取。\n\n**注意：如上只是不对反向代理的页面进行缓存设置的，但是如果是反向代理后的页面，如上设置是不生效的。比如说我 node 起了一个服务，然后通过访问 nginx 反向代理的方式代理到我 node 服务来，上面的配置是不生效的。因此我们需要如下处理配置**\n\n## 解决 nginx 反向代理缓存不起作用的问题\n\n比如我上面的 node 服务端口是 7878 端口。nginx 需要如下配置：\n\n```bash\nserver {\n  listen  8081;\n  server_name  xxx.abc.com;\n  location / {\n    proxy_pass http://localhost:7878;\n    add_header  Cache-Control  max-age=no-cache;\n  }\n}\n```\n\n1 如果我们要添加缓存功能的话，需要创建一个用于存放缓存文件的文件夹。比如我们这里使用 /data/nuget-cache。  \n2 然后我们需要在 nginx.conf 的 http 设置部分添加 proxy_cache_path 的设置，如下：\n\n```bash\nhttp {\n  // ..... 其他的配置\n  proxy_cache_path  /data/nuget-cache levels=1:2 keys_zone=nuget-cache:20m max_size=50g inactive=168h;\n  server {\n    listen  8081;\n    server_name  xxx.abc.com;\n    location / {\n      proxy_pass http://localhost:7878;\n      add_header  Cache-Control  max-age=no-cache;\n    }\n  }\n}\n```\n\nproxy_cache_path 各个配置值的含义解析如下：\n\n- proxy_cache_path 指缓存的目录，目录为：/data/nuget-cache。\n- levels=1:2 表示采用 2 级目录结构。\n- keys_zone 指的是缓存空间名称，叫 nuget-cache。缓存内存的空间为 20M。\n- max_size 指的是缓存文件可以占用的最大空间，为 50G。\n- inactive=168h; 默认过期时间为 168 个小时。为 7 天，也可以写成：inactive=7d; 这样的格式。\n\n3 我们还需要在 server 设置部分添加 proxy_cache 与 proxy_cache_valid 的设置：\n\n```bash\nhttp {\n  // ..... 其他的配置\n  proxy_cache_path  /data/nuget-cache levels=1:2 keys_zone=nuget-cache:20m max_size=50g inactive=168h;\n  server {\n    listen  8081;\n    server_name  xxx.abc.com;\n    location / {\n      proxy_pass http://localhost:7878;\n      add_header  Cache-Control  max-age=no-cache;\n      proxy_cache nuget-cache;\n      proxy_cache_valid 168h;\n      proxy_ignore_headers Set-Cookie Cache-Control;\n      proxy_hide_header Cache-Control;\n      proxy_hide_header Set-Cookie;\n    }\n  }\n}\n```\n\n- proxy_cache 设置的是 proxy_cache_path 中的 keys_zone 的值。\n- proxy_cache_valid：设置的是缓存过期时间，比如设置 168 个小时过期。\n- proxy_ignore_headers 的含义是：忽略 Cache-Control 的请求头控制，依然进行缓存，比如对请求头设置 cookie 后，默认是不缓存的，需要我们增加忽略配置。  \n  至此 nginx 缓存配置就完成了，重启 nginx，发现已经可以实现缓存了。\n",
			"articleWords": 2431,
			"articleReadTime": "8.1",
			"articleKeyWords": "nginx,nginx缓存",
			"articleDescription": "Nginx作为Web缓存服务器，它介于客户端和应用服务器之间，当用户通过浏览器访问一个URL时，web缓存服务器会去应用服务器获取要展示给用户的内容，将内容缓存到自己的服务器上，当下一次请求到来时，如果访问的是同一个URL，web缓存服务器就会直接将之前缓存的内容返回给客户端，而不是向应用服务器再次发送请求。web缓存降低了应用服务器、数据库的负载，减少了网络延迟，提高了用户访问的响应速度，增强了用户的体验。",
			"articleAvatar": "https://cdn.staticaly.com/gh/AnyFork/blog-images/main/markdown/202207201016051.jpg",
			"articleReadCount": 2,
			"articleStatus": "0",
			"categoryInfo": {
				"createdTime": "2023-06-04 18:18:39",
				"createdBy": 1,
				"categoryId": "1665302031547015169",
				"categoryName": "Java",
				"iconName": "devicon:java-wordmark",
				"categoryStatus": "0",
				"categoryAlias": "java",
				"orderNum": 42,
				"articleTotal": 0
			},
			"tagInfo": []
		},
		{
			"createdTime": "2022-12-21 14:34:57",
			"createdBy": 1,
			"articleId": "1605451737395634178",
			"articleTitle": "nginx 内容简介和性能分析",
			"articleSummary": "Nginx是一个高性能的 HTTP 和反向代理 web 服务器，同时也提供了IMAP/POP3/SMTP 服务。适合做静态文件处理和反向代理服务器，轻量级,非阻塞，支持高并发，高抗压，耗费内存少。同时支持故障转移，负载均衡等功能。",
			"articleCategory": "1665302031547015169",
			"articleContent": "## 一、nginx 简介\n\n:::tip\nNginx (engine x) 是一个高性能的 HTTP 和反向代理 web 服务器，同时也提供了 IMAP/POP3/SMTP 服务。Nginx 是由伊戈尔·赛索耶夫为俄罗斯访问量第二的 Rambler.ru 站点（俄文：Рамблер）开发的，第一个公开版本 0.1.0 发布于 2004 年 10 月 4 日。\n其将源代码以类 BSD 许可证的形式发布，因它的稳定性、丰富的功能集、简单的配置文件和低系统资源的消耗而闻名。2011 年 6 月 1 日，nginx 1.0.4 发布。\nNginx 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在 BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上 nginx 的并发能力在同类型的网页服务器中表现较好，中国大陆使用 nginx 网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。\n:::\n\n## 二、Nginx 的优点\n\n1、**跨平台**：Nginx 可以在大多数 Unix like OS 编译运行，而且也有 Windows 的移植版本。\n\n2、**简单稳定**：配置简单，非常容易上手，基本在一个 conf 文件中配置，性能比较稳定，用于反向代理，宕机的概率微乎其微，可以 7\\*24 小时长时间不间断运行手。\n\n3、**非阻塞**、高并发连接：数据复制时，磁盘 I/O 的第一阶段是非阻塞的。官方测试能够支撑 5 万并发连接，在实际生产环境中跑到 2 ～ 3 万并发连接数.(这得益于 Nginx 使用了最新的 epoll 模型)\n\n4、**事件驱动**：通信机制采用 epoll 模型，支持更大的并发连接。\n\n5、**master/worker 结构**：一个 master 进程，生成一个或多个 worker 进程\n\n6、**内存消耗小**：处理大并发的请求内存消耗非常小。在 3 万并发连接下，开启的 10 个 Nginx 进程才消耗 150M 内存（15M\\*10=150M）\n\n7、**成本低廉**：Nginx 可以做高并发的负载均衡，且 Nginx 是开源免费的。而购买 F5 BIG-IP、NetScaler 等硬件负载均衡交换机则需要十多万至几十万人民币\n\n8、**内置的健康检查功能**：NGINX 能够根据应用服务器处理页面返回的状态码、超时信息等检测服务器是否出现故障，并及时返回错误的请求重新提交到其它节点上\n\n9、**节省带宽**：支持 GZIP 压缩，可以添加浏览器本地缓存的 Header 头。\n\n10、**稳定性高**：用于反向代理，宕机的概率微乎其微\n\n11、**模块化程度高**：Nginx 是高度模块化的设计，编写模块相对简单，包括 gzipping, byte ranges, chunked responses,以及 SSI-filter 等 filter，支持 SSL 和 TLSSNI。\n\n12、**支持 Rwrite 重写规则**：能够根据域名、URL 的不同， 将 HTTP 请求分发到不同的后端服务器群组。\n\n13、**支持反向代理和负载均衡**：nginx 支持反向代理和负载均衡的功能。\n\n14、nginx 代理和后端 web 服务器间无需长连接；\n\n15、接收用户请求是异步的，即先将用户请求全部接收下来，再一次性发送后后端 web 服务器，极大的减轻后端 web 服务器的压力。\n\n16、送响应报文时，是边接收来自后端 web 服务器的数据，边发送给客户端的。\n\n17、网络依赖型低。NGINX 对网络的依赖程度非常低，理论上讲，只要能够 ping 通就可以实施负载均衡，而且可以有效区分内网和外网流量。\n\n## 三、Nginx 的缺点\n\n1、**动态处理差**：Nginx只适合静态和反向代理，nginx 处理静态文件好,耗费内存少，但是处理动态页面则很鸡肋，现在一般前端用 nginx 作为反向代理抗住压力，apache 作为后端处理动态请求。\n\n2、**rewrite 弱**：虽然 nginx 支持 rewrite 功能，但是相比于 Apache 来说，Apache 比 nginx 的 rewrite 强大。\n\n## 四、功能对比\n\n### Nginx 和 tomcat 的区别\n\n&emsp;nginx 常用做静态内容服务和代理服务器，直接外来请求转发给后面的应用服务器（tomcat，Django 等），tomcat 更多用来做一个应用容器，让 java web app 泡在里面的东西。严格意义上来讲，Apache 和 nginx 应该叫做 HTTP Server，而 tomcat 是一个 Application Server 是一个 Servlet/JSO 应用的容器。客户端通过 HTTP Server 访问服务器上存储的资源（HTML 文件，图片文件等），HTTP Server 是中只是把服务器上的文件如实通过 HTTP 协议传输给客户端。应用服务器往往是运行在 HTTP Server 的背后，执行应用，将动态的内容转化为静态的内容之后，通过 HTTP Server 分发到客户端\n注意：nginx 只是把请求做了分发，不做处理！！\n\n### Nginx 和 Apache 的区别\n\n&emsp;Apache 是同步多进程模型，一个连接对应一个进程，而 nginx 是异步的，多个连接（万级别）可以对应一个进程。nginx 轻量级，抗并发，处理静态文件好\nApache 超稳定，对 PHP 支持比较简单，nginx 需要配合其他后端用，处理动态请求有优势，建议使用前端 nginx 抗并发，后端 apache 集群，配合起来会更好，nignx 的正向代理和反向代理\n\n**1、nginx 相对于 apache 的优点**\n\n:::tip\n轻量级，同样起 web 服务，比 apache 占用更少的内存及资源 抗并发，nginx 处理请求是异步非阻塞的，而 apache 则是阻塞型的，在高并发下 nginx 能保持低资源低消耗高性能高度模块化的设计，编写模块相对简单提供负载均衡,社区活跃，各种高性能模块出品迅速\n:::\n**2、apache 相对于 nginx 的优点**\n\n:::tip\napache 的 rewrite（重写） 比 nginx 的强大 ;支持动态页面;支持的模块多，基本涵盖所有应用;性能稳定，而 nginx 相对 bug 较多。\n:::\n\n**3、两者优缺点比较**\n\n:::tip\nNginx 配置简洁, Apache 复杂 ;\nNginx 静态处理性能比 Apache 高 3 倍以上 ;\nApache 对 PHP 支持比较简单，Nginx 需要配合其他后端用;Apache 的组件比 Nginx 多 ;\napache 是同步多进程模型，一个连接对应一个进程;nginx 是异步的，多个连接(万级别)可以对应一个进程;\nnginx 处理静态文件好,耗费内存少;\n动态请求由 apache 去做，nginx 只适合静态和反向;\nNginx 适合做前端服务器，负载性能很好;\nNginx 本身就是一个反向代理服务器 ，且支持负载均衡\n:::\n",
			"articleWords": 1693,
			"articleReadTime": "5.64",
			"articleKeyWords": "nginx",
			"articleDescription": "Nginx是一个高性能的 HTTP 和反向代理 web 服务器，同时也提供了IMAP/POP3/SMTP 服务。适合做静态文件处理和反向代理服务器，轻量级,非阻塞，支持高并发，高抗压，耗费内存少。同时支持故障转移，负载均衡等功能。",
			"articleAvatar": "https://cdn.staticaly.com/gh/AnyFork/blog-images/main/markdown/202209041530281.png",
			"articleReadCount": 0,
			"articleStatus": "0",
			"categoryInfo": {
				"createdTime": "2023-06-04 18:18:39",
				"createdBy": 1,
				"categoryId": "1665302031547015169",
				"categoryName": "Java",
				"iconName": "devicon:java-wordmark",
				"categoryStatus": "0",
				"categoryAlias": "java",
				"orderNum": 42,
				"articleTotal": 0
			},
			"tagInfo": []
		}
	]
}
